
<!-- saved from url=(0083)#01-NginxVariables01 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>agentzh's Nginx Tutorials (version 2012.09.28)</title>
    <link href="./bootstrap/css/bootstrap.css" rel="stylesheet">
    <link href="./bootstrap/css/bootstrap-responsive.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Share+Tech+Mono' rel='stylesheet' type='text/css'>

    <style type="text/css">
        body{
           margin: 0px auto;
           width: 90%;
            font-family: 'Open Sans', sans-serif;
            color: #555; 
        }


        p{
            line-height: 1.5;
        }
       
        code{
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            background-color: #fdf6e3;
            color: #555;
            display: inline-block;
            padding: 12px;
            padding-left: 0;
            padding-right: 36px;
            border: 1px dashed #002b36;
            border-radius: 10px;
            margin-bottom: 8px;
        }
        p code{
            padding: 0;
            border: 0;
            border-radius: 0;
            margin: 0;
        }

        #articles h3{
            margin-top: 50px;
        }

        #main a:link{
            color: #268bd2;
        }

        #main a:visited{
            color: #888
        }



        ul{
            list-style: none;
            margin-left: 0;
        }

        #main{
            margin-top: 20px;
        }

        .sidebar-nav-fixed {
             position:fixed;
             top:80px;
             padding: 0;
         }
         .sidebar-nav {
            padding: 0 20px;
         }

         @media (max-width: 767px) {
             .sidebar-nav-fixed {
                 width:auto;
                 padding: 0;
             }
             .sidebar-nav {
            padding: 0 20px;
         }
         }

         @media (max-width: 979px) {
             .sidebar-nav-fixed {
                position:static;
                width: auto;
                padding: 0;
             }
             .sidebar-nav {
            padding: 0 20px;
         }
        }

    </style>
</head>
    <body class="container"><h2>agentzh's Nginx Tutorials (version 2012.09.28)</h2>
    <div class="row-fluid" id="main">
    <div class="span4">
        <div class="well sidebar-nav sidebar-nav-fixed">
    <h3>Table of Contents</h3>
    <ul>
    <li><a href="#00-Foreword01">Foreword</a></li>
    <li><a href="#00-Foreword02">Writing Plan for the Tutorials</a></li>
    <li><a href="./agentzh's Nginx Tutorials (version 2012.09.28)_files/agentzh's Nginx Tutorials (version 2012.09.28).htm">Nginx Variables (01)</a></li>
    <li><a href="#01-NginxVariables02">Nginx Variables (02)</a></li>
    <li><a href="#01-NginxVariables03">Nginx Variables (03)</a></li>
    <li><a href="#01-NginxVariables04">Nginx Variables (04)</a></li>
    <li><a href="#01-NginxVariables05">Nginx Variables (05)</a></li>
    <li><a href="#01-NginxVariables06">Nginx Variables (06)</a></li>
    <li><a href="#01-NginxVariables07">Nginx Variables (07)</a></li>
    <li><a href="#01-NginxVariables08">Nginx Variables (08)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder01">Nginx Directive Execution Order (01)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder02">Nginx Directive Execution Order (02)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder03">Nginx Directive Execution Order (03)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder04">Nginx Directive Execution Order (04)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder05">Nginx Directive Execution Order (05)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder06">Nginx Directive Execution Order (06)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder07">Nginx Directive Execution Order (07)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder08">Nginx Directive Execution Order (08)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder09">Nginx Directive Execution Order (09)</a></li>
    <li><a href="#02-NginxDirectiveExecOrder10">Nginx Directive Execution Order (10)</a></li>
</ul>
    </div>
</div>
<div class="span8" id="articles">
    <h3 id="00-Foreword01">Foreword</h3>
<p>I've been doing a lot of work in the Nginx world over the last few years and I've also been thinking about writing series of tutorial-like articles to explain to more people what I've done and what I've learned in this area. Now I have finally decided to post serial tutorials to the Sina Blog <a href="http://blog.sina.com.cn/openresty" target="_blank">http://blog.sina.com.cn/openresty</a> in Chinese. Every article will have one rough topic and will be in a rather casual style. They're not parts of a book after all. But I do have plans to re-orginaize these stuffs to form a real book.
</p>
<p>Now the tutorials being written is devided into "series". For example, the first series is "Nginx Variables". Each series can be roughly mapped to a chapter in the Nginx book that I may publish in the future (of course, I will also reorganize the contents to form "sections"). The tutorials are intended for Nginx users at various levels, including those Apache and Lighttpd users who have never used Nginx before.
</p>
<p>The samples in my tutorials are at least compatible with Nginx <code>0.8.54</code>; do not try the samples with older versions of Nginx. The latest stable version as of this writing is <code>1. 0.10</code> after all.
</p>
<p>All of the Nginx modules mentioned in these tutorials are production-ready. I will not even mention those standard Nginx modules that are either experimental or buggy.
</p>
<p>I'm going to make extensive use of Nginx 3rd-party modules here. If you' re too lazy to download and install those modules one by one, then you are recommended to download and install the <code>ngx_openresty</code> software bundle that is maintained by me.
</p>
<p><a href="http://openresty.org/" target="_blank">http://openresty.org/</a>
</p>
<p>All of the modules mentioned in these tutorials, including the Nginx stable core that is fresh enough, have included in this bundle.
</p>
<p>One principle that I've been trying to follow in these tutorials is to use small and concise configure examples to validate the concepts and principles that are being explained. I hope this can help the reader to build the good habit of not accepting others' viewpoints or statements without testing them. This style may have something to do with my QA background. In fact, I keep adjusting and correcting my words according to the running results of my little samples in the process of writing.
</p>
<p>For problematic code samples, we will intentionally make them look different from those good samples, that is, all the lines of the bad samples will be prefixed with a question mark, i.e., "<code>?</code>". Here is an example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bad&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Do not reproduce these articles without explicit permissions from us. Copyright reserved.
</p>
<p>I welcome the readers to send feedback to me (<code>agentzh@gmail.com</code>), especially constructive criticisms.
</p>
<p>The source for all the articles has been put onto the GitHub web site and is under version control:
</p>
<p><a href="http://github.com/agentzh/nginx-tutorials/" target="_blank">http://github.com/agentzh/nginx-tutorials/</a>
</p>
<p>The source files are under the <code>en-uk/</code> directory. I am using a little markup language that is a mixture of <code>Wiki</code> and <code>POD</code> to write these articles. They are just those <code>.tut</code> files. You are very welcome to create forks and/or provide patches.
</p>
<p>The e-books files that are suitable for cellphones, Kindle, iPad/iPhone, Sony Readers, and other devices, can be downloaded from here:
</p>
<p><a href="http://openresty.org/#eBooks" target="_blank">http://openresty.org/#eBooks</a>
</p>
<p>Special thanks go to Kai Wu (kai10k) who kindly translates these tutorials to English.
</p>
<p>agentzh at home in the Fuzhou city
</p>
<p>October 30, 2011</p>
    <h3 id="00-Foreword02">Writing Plan for the Tutorials</h3>
<p>Here lists the tutorial series that have already been published or to be published.
</p>
<ul>
<li>Getting Started with Nginx</li>
<li>How Nginx Matches URIs</li>
<li><a href="./agentzh's Nginx Tutorials (version 2012.09.28)_files/agentzh's Nginx Tutorials (version 2012.09.28).htm">Nginx Variables</a></li>
<li><a href="#02-NginxDirectiveExecOrder01">Nginx Directive Execution Order</a></li>
<li>Nginx's if is Evil</li>
<li>Nginx Subrequests</li>
<li>Nginx Static File Services</li>
<li>Nginx Log Services</li>
<li>Application Gateways based on Nginx</li>
<li>Reverse-Proxies based on Nginx</li>
<li>Nginx and Memcached</li>
<li>Nginx and Redis</li>
<li>Nginx and MySQL</li>
<li>Nginx and PostgreSQL</li>
<li>Application caching Based on Nginx</li>
<li>Security and Access Control in Nginx</li>
<li>Web Services Based on Nginx</li>
<li>AJAX Applications Driven by Nginx</li>
<li>Performance Testing for Nginx and its Applications</li>
<li>Strength of the Nginx Community</li>
</ul>
<p>The series names can roughly correspond to the chapter names in my final Nginx book, but they are unlikely to stay exactly the same. The actual series names may change and the relative order of the series may change as well.
</p>
<p>The list above will be constantly updated to always reflect the latest plan.</p>
    <h3 id="01-NginxVariables01">Nginx Variables (01)</h3>
<p>Nginx's configuration is itself a mini language. Many Nginx configurations are practically programs. The language might not be Turing-Complete, as far as I can see, its design is heavily influenced by Perl and Bourne Shell. This is a characteristic feature of Nginx, comparing to the other web servers such as Apache or Lighttpd. Being a language, "Variable" declaration becomes a common concept (However, exception does exist in Functional Languages such as Haskell)
</p>
<p>For those who know well imperative languages like Perl, Bourne Shell, C/C++, variable is nothing but a container holding various values, and the "value" can be numbers like <code>3.14</code> or strings like <code>hello world</code>. Values can be as complicated as references to arrays or hash tables too. However in the Nginx configuration, variable contains one and only one type of value: strings.
</p>
<p>For example, our <code>nginx.conf</code> has following variable declaration:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;"hello&nbsp;world";<br>
</code><p>We have used built-in  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> module's  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> command to declare and initialize the variable <code>$a</code>. Specifically, it is assigned with strings <code>hello world</code>. Like Perl and PHP, the Nginx syntax requires prefix <code>$</code> to declare and devalue variables.
</p>
<p>Many <code>Java</code> and <code>C#</code> programmers dislike the ugly <code>$</code> variable prefix, yet the approach does have a few advantages, notably, variables can be embedded directly in a string to construct another string
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;hello;<br>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$b&nbsp;"$a,&nbsp;$a";<br>
</code><p>It is using Nginx variable <code>$a</code>, to construct variable <code>$b</code>. Now <code>$a</code> is <code>hello</code>, and <code>$b</code> is <code>hello, hello</code>. The technique is called "variable interpolation" in Perl. It effectively executes the string concatenation.
</p>
<p>Let's have a look at another example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$foo&nbsp;hello;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"foo:&nbsp;$foo";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>The example omits the outter <code>http</code> directive and <code>events</code> directive in <code>nginx.conf</code>. With the HTTP client utility <code>curl</code>, we can issue a HTTP request to <code>/test</code> from command line and obtain following result:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;foo:&nbsp;hello<br>
</code><p>Here we use 3rd party module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> and its command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> to print the value of variable <code>$foo</code> as HTTP response.
</p>
<p>We can assert that  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> supports "variable interpolation", yet we must not take it for granted, since not all the variable commands supports "variable interpolation" and it is in fact up to the module's implementation.
</p>
<p>Is there any way to escape <code>$</code> so that it is no more than a typical dollar sign by using  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> ? The answer is negative (the answer still holds in the latest Nginx stable release <code>1.0.10</code>. Luckily this can be done by other module commands, which designate <code>$</code> value as a Nginx variable, then the variable can be used in  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>, example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;geo&nbsp;$dollar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;"$";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"This&nbsp;is&nbsp;a&nbsp;dollar&nbsp;sign:&nbsp;$dollar";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>testing result is following:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;is&nbsp;a&nbsp;dollar&nbsp;sign:&nbsp;$<br>
</code><p>The built-in module  <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank">ngx_geo</a> and its command  <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank">geo</a> are used to initialize variable <code>$dollar</code> with string <code>"$"</code>, thereafter variable <code>$dollar</code> can be used for circumstances asking for a dollar sign. Actually, the typical scenario  <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank">ngx_geo</a> is applied for, is to assign Nginx variable by taking into account the request client IP addresses. For above specific example, it is used to initialize <code>$dollar</code> variable with the dollar sign string unconditionally.
</p>
<p>Attention, "variable interpolation" has a special case, where the variable name itself cannot be delimited from the rest of the string (such as it is right in front of letter, digit or underscore) Hence a special syntax is needed to handle the case, as following:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$first&nbsp;"hello&nbsp;";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"${first}world";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>In the example, variable <code>$first</code> is concatenated with <code>world</code>. If it is written directly as <code>"$firstworld"</code>, Nginx's variable interpolation tries to devalue variable <code>$firstworld</code> instead of <code>$first</code>. To fix this problem, curly bracket can be used together with <code>$</code>, such as <code>${first}</code>. Above example has following result:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;world<br>
</code><p>Command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> (and Command  <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank">geo</a>) not only initialize a variable, effectively it firstly declares the variable. Which means, if the variable is not declared yet, it is declared automatically (then initialized). In the example, if variable <code>$a</code> is not declared, <code>set</code> declares the variable at first hand. If variables are not declared, Nginx cannot devalue them, another example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bad&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Nginx aborts loading configuration:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[emerg]&nbsp;unknown&nbsp;"foo"&nbsp;variable<br>
</code><p>Yes, the server cannot even be started!
</p>
<p>More importantly, Nginx variable declaration and initialization happens at different phases in the timeline. Variable declaration only occurs when Nginx loads its configuration, in other words, when Nginx is started. On the other hand, variable initialization occurs when actual request is being handled. Consequently, server fails bootstrap if variable is not declared, further more, new Nginx variables cannot be declared dynamically in the run time.
</p>
<p>As soon as a variable is declared in Nginx, its scope is the entire configuration, regardless of the location it is referenced, even for different virtual server directives. Here is an example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"foo&nbsp;=&nbsp;[$foo]";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$foo&nbsp;32;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"foo&nbsp;=&nbsp;[$foo]";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Variable <code>$foo</code> is declared by command <code>set</code> within <code>location /bar</code>, as variable visibility is the entire configuration. It can be referenced in <code>location /foo</code> without causing any error, following are the location outcomes respectively:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/foo'<br>
&nbsp;&nbsp;&nbsp;&nbsp;foo&nbsp;=&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/bar'<br>
&nbsp;&nbsp;&nbsp;&nbsp;foo&nbsp;=&nbsp;[32]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/foo'<br>
&nbsp;&nbsp;&nbsp;&nbsp;foo&nbsp;=&nbsp;[]<br>
</code><p>As we can tell, command <code>set</code> is executed within <code>location /bar</code>, so the variable is only initialized when <code>/bar</code> is requested. If <code>/foo</code> is requested directly, variable <code>$foo</code> has an empty value. Default value is an empty string if Nginx variable is not initialized.
</p>
<p>The example carries another important feature, i.e. although variable scope is the entire configuration, every request has its own copies of the declared variables. In the example, variable <code>$foo</code> is initialized with value <code>32</code> when <code>/bar</code> is requested, but it remains empty in the subsequent request to <code>/foo</code> since every request has their own copy of variables
</p>
<p>This is a common pitfall many Nginx newbie stumbles, which is to think Nginx variable as "global variable" or configuration settings that are shared for the entire server life time. In fact, variables cannot last in between different requests.</p>
    <h3 id="01-NginxVariables02">Nginx Variables (02)</h3>
<p>One common misunderstanding with Nginx variable, is its life cycle be bounded with the <code>Location</code> directive. Let's challenge it by checking another example
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;hello;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_exec&nbsp;/bar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"a&nbsp;=&nbsp;[$a]";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>We use the 3rd party module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> and its command  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> to execute <code>location /bar</code> from within <code>location /foo</code>. The mechanism is like "jumping" from one <code>location</code> to another <code>location</code> in Nginx internals when handling a specific request. This is different with HTTP <code>301</code> and <code>302</code> redirect, which conducts the external jump by collaborating with HTTP client. External redirect can be asserted when requesting URL is modified. Whereas Nginx internal jumps has no impact on the client side, and just like the <code>exec</code> command found in <code>Bourne Shell</code> (or <code>Bash</code>), the execution path has no returns. Another close schema is the <code>goto</code> statement in <code>C</code>.
</p>
<p>Being an internal jump in between the <code>location</code> directives for Nginx processing, the request remains to be the original one, its copy of declared variables has not changed neither. Back to our example, if <code>/foo</code> is requested, the processing is like following: variable <code>$a</code> is declared and initialized with string value <code>hello</code> by command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> within <code>location</code> directive, then internal jump occurs by  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> and processing continues from <code>location /bar</code>. Since <code>$a</code> in the latter case is the same <code>$a</code> variable initialized earlier we can expect the outcome is <code>hello</code> when variable <code>$a</code> is printed. Let' s prove ourselves with request:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;localhost:8080/foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;[hello]<br>
</code><p>If however, the <code>/bar</code> is requested directly, <code>$a</code> still has an empty value because it is initialized in <code>location /foo</code> only.
</p>
<p>The example tells, when a request is being handled, even across multiple <code>location</code> directives, its copy of Nginx variables has not been reconstructed. The concept of "internal jumps" is also worth of noting, that the built-in  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> module and its command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> can execute exactly the same kind of internal jump. To rewrite our example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;hello;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^&nbsp;/bar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"a&nbsp;=&nbsp;[$a]";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
</code><p>Net effect has no differences with  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a>.  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> will be addressed more specifically later, for its usage in <code>301</code> and <code>302</code> redirects.
</p>
<p>Again, we have asserted that Nginx variable's life time is bounded with the request being handled and it has nothing to do with <code>location</code> directives.
</p>
<p>So far, the variables we have discussed are implicitly created by  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>. They are called "user defined variables" or simply "user variables". Besides variables defined by user, Nginx core and various Nginx modules can provide "pre-defined variables" or "builtin variables).
</p>
<p>Builtin variables are mostly used to provide request or response information. For instance builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a>, declared by <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank">ngx_http_core</a> module, gives the URI of the request being handled (url-decoded and exclude request parameters). Another builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank">$request_uri</a> gives the original request URI (url-encoded and include request parameter). Another example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"uri&nbsp;=&nbsp;$uri";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"request_uri&nbsp;=&nbsp;$request_uri";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>for the sake of clearness, <code>server</code> directive is omitted. As usual the server is listening on <code>8080</code> port, the example prints Nginx builtin variables  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> and  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank">$request_uri</a> in the response. Now let's send a request to <code>test</code>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;uri&nbsp;=&nbsp;/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;request_uri&nbsp;=&nbsp;/test<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?a=3&amp;b=4'<br>
&nbsp;&nbsp;&nbsp;&nbsp;uri&nbsp;=&nbsp;/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;request_uri&nbsp;=&nbsp;/test?a=3&amp;b=4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test/hello%20world?a=3&amp;b=4'<br>
&nbsp;&nbsp;&nbsp;&nbsp;uri&nbsp;=&nbsp;/test/hello&nbsp;world<br>
&nbsp;&nbsp;&nbsp;&nbsp;request_uri&nbsp;=&nbsp;/test/hello%20world?a=3&amp;b=4<br>
</code><p>There is another category of builtin variables, these variable names has the <code>arg_</code> prefix, such as <code>$arg_name</code>, its value is the url-encoded URI parameter <code>name</code>, here is a finer example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"name:&nbsp;$arg_name";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"class:&nbsp;$arg_class";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>We test <code>/test</code> with a few scenarios, each with different URL parameter
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;class:&nbsp;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?name=Tom&amp;class=3'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;Tom<br>
&nbsp;&nbsp;&nbsp;&nbsp;class:&nbsp;3<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?name=hello%20world&amp;class=9'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;hello%20world<br>
&nbsp;&nbsp;&nbsp;&nbsp;class:&nbsp;9<br>
</code><p><code>$arg_name</code> is case-insensitive, it matches to <code>name</code> URL parameter and it matches the <code>NAME</code> or <code>Name</code> as well:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?NAME=Marry'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;Marry<br>
&nbsp;&nbsp;&nbsp;&nbsp;class:&nbsp;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?Name=Jimmy'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;Jimmy<br>
&nbsp;&nbsp;&nbsp;&nbsp;class:&nbsp;<br>
</code><p>Nginx lower-cases all URL parameter keys before it declares those builtin variables.
</p>
<p>A 3rd party module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a> and its command  <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank">set_unescape_uri</a> can execute URL decoding for string sequences like <code>%XX</code>
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_unescape_uri&nbsp;$name&nbsp;$arg_name;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_unescape_uri&nbsp;$class&nbsp;$arg_class;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"name:&nbsp;$name";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"class:&nbsp;$class";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Again:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?name=hello%20world&amp;class=9'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;hello&nbsp;world<br>
&nbsp;&nbsp;&nbsp;&nbsp;class:&nbsp;9<br>
</code><p>white space is decoded !
</p>
<p>As we can see, command  <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank">set_unescape_uri</a> is like command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> has the capability of declare and initialize Nginx variables. Later on we will discuss more of the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> module.
</p>
<p>Variables like  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a>, are declared specifically within Nginx core. 3rd party module has no equivalent capabilities. There are similar category of variables, <code>$cookie_XXX</code> to retrieve cookie,  <a href="http://wiki.nginx.org/HttpCoreModule#.24http_HEADER" target="_blank">$http_XXX</a> the headers and  <a href="http://wiki.nginx.org/HttpCoreModule#.24sent_http_HEADER" target="_blank">$sent_http_XXX</a> response headers. Please reference official documentation of <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank">ngx_http_core</a> module for details.
</p>
<p>Attention, many builtin variables are read-only. Such as the one we have lately introduced  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> and  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank">$request_uri</a>. One must avoid to assign values to read-only variables, unless they enjoy surprises, for example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bad&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$uri&nbsp;/blah;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$uri;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>This problematic configuration dumps fatal error when Nginx is started and leaves absolute no clue:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[emerg]&nbsp;the&nbsp;duplicate&nbsp;"uri"&nbsp;variable&nbsp;in&nbsp;...<br>
</code><p>Attempt to write other read-only variables such as  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> variables, can blow the Nginx process right away in a few particular releases.</p>
    <h3 id="01-NginxVariables03">Nginx Variables (03)</h3>
<p>Some builtin variables are writable.  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is one of them. The variable gives the URL parameters (the part after the question mark) when the variable is written, the parameters are virtually modified. Let' s check following example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$orig_args&nbsp;$args;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$args&nbsp;"a=3&amp;b=4";<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"original&nbsp;args:&nbsp;$orig_args";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"args:&nbsp;$args";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>The original URL parameters are saved in <code>$origin_args</code> variable, then we change the URL parameters by modifying  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, finally both <code>$orig_args</code> and  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> are printed by command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>. Now we can launch request to <code>/test</code>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;original&nbsp;args:&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;args:&nbsp;a=3&amp;b=4<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?a=0&amp;b=1&amp;c=2'<br>
&nbsp;&nbsp;&nbsp;&nbsp;original&nbsp;args:&nbsp;a=0&amp;b=1&amp;c=2<br>
&nbsp;&nbsp;&nbsp;&nbsp;args:&nbsp;a=3&amp;b=4<br>
</code><p>In the first run, no URL parameters are sent in the request, <code>$orig_args</code> has an empty value. Yet in both runs, URL parameters are rewritten as <code>a=3&amp;b=4</code> no matter how it is requested.
</p>
<p>If we drill deeper, variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> like  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a>, is no longer a simple value container. In fact, whenever  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is devalued, Nginx core runs a chunk of code to calculate it from where the URL parameters are stored, when the variable is written, another chunk of code get executed to overwrite the same storage.This is how it is actually implemented. Now let's run following test
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$orig_a&nbsp;$arg_a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$args&nbsp;"a=5";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"original&nbsp;a:&nbsp;$orig_a";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"a:&nbsp;$arg_a";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p><code>$orig_a</code> saves a copy of the original <code>$arg_a</code>, which is the value of URL parameter <code>a</code>. then  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is rewritten as <code>a=5</code>, finally both <code>$orig_a</code> and <code>$arg_a</code> are printed by command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>. Since overwriting variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> effectively modifies the URL parameters, builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> should have been modified as well, this can be verified as following:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?a=3'<br>
&nbsp;&nbsp;&nbsp;&nbsp;original&nbsp;a:&nbsp;3<br>
&nbsp;&nbsp;&nbsp;&nbsp;a:&nbsp;5<br>
</code><p>Clearly, URL parameter was <code>a=3</code>, builtin variable <code>$arg_a</code> was initialized with value <code>3</code>, right after  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> gets modified as <code>a=5</code>, <code>$arg_a</code> now has the value <code>5</code>.
</p>
<p>Modify <code>$args</code> has another side effect for builtin HTTP proxy module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$args&nbsp;"foo=1&amp;bar=2";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;http://127.0.0.1:8081/args;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8081;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/args&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"args:&nbsp;$args";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Two virtual servers are configured within <code>http</code> directive, one is listening on port 8080, it modifies the  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> variable, so that the request URL parameter becomes <code>foo=1&amp;bar=2</code> as long as <code>/test</code> is requested. Thereafter  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> and its command  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a> are used to proxy the request to the other virtual server, which is listening on port 8081 for location <code>/args</code>. By default when proxy is happening, URL parameters of the original request will be proxyed as well.
</p>
<p>When the latter virtual server has the request on port 8081, it uses command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> to print the current URL parameters, so that we can check what was actually proxyed from <code>/test</code>, let's roll it out:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?blah=7'<br>
&nbsp;&nbsp;&nbsp;&nbsp;args:&nbsp;foo=1&amp;bar=2<br>
</code><p>You might have noticed, the original request has URL parameter <code>blah=7</code>, but it gets overwritten within <code>location /test</code> as <code>foo=1&amp;bar=2</code>, so when the request is proxyed to the latter virtual server by command  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a>, the original URL parameter is gone and new value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is printed.
</p>
<p>The hook under the scene, when Nginx variable is retrieved, is called " get handler" while the one in charge when Nginx variable is written, is called "set handler", since different Nginx module has the caliber to provide those handlers for their variables, variables become really powerful.
</p>
<p>This technique is not uncommon in programming. One example is the class designer,who enjoys Object-Oriented programming, seldom exposes their class member variables, instead two acessor methods are provided respectively for read and write. A simple C++ case:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#include&nbsp;&lt;string&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;using&nbsp;namespace&nbsp;std;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Person&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;public:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;string&nbsp;get_name()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;m_name;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;set_name(const&nbsp;string&nbsp;name)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_name&nbsp;=&nbsp;name;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;private:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;m_name;<br>
&nbsp;&nbsp;&nbsp;&nbsp;};<br>
</code><p>Two public methods <code>get_name</code> and <code>set_name</code> are provided, they are the acessor methods for the private member variable <code>m_name</code>
</p>
<p>The design has great flexibility, as any logic can be inserted into "acessor method" if necessary. Such as update other member variables who have dependences, or modify directly the corresponding table back in a database.In the latter case, "acessor method" might not have a member variable at all, or probably its sole purpose is to cache the database returns.
</p>
<p>Like the "acessor methods" in Object-Oriented programming, Nginx variables are bounded with "set/get handlers". When Nginx variable declares its variables, it has the option to allocate a value container or hook it with "set/get handlers"
</p>
<p>Not every Nginx variable has its value container. For those who have, they are called "indexed" in Nginx core. Otherwise they are called "non-indexed" .
</p>
<p>As we learnt from <a href="#01-NginxVariables02">(02)</a>, the variable category like  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> are non-indexed, the read and write of those variables are executed through "set/get handlers" , i.e. by calculating the URL parameters in run time. Newbies might imagine those URL parameters are parsed once for all, and the corresponding  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> variables are accordingly declared and initialized. Well this is false. Nginx does not parse URL parameter sequence beforehand, instead it calculates it when a  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> needs to be devalued, through the "set/get handler". The same approach applies to  <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank">$cookie_XXX</a> variables too, its "set/get handler" calculates from the <code>Cookie</code> headers in the run time.</p>
    <h3 id="01-NginxVariables04">Nginx Variables (04)</h3>
<p>Even if a Nginx variable is hooked with "get handler", it can opt-in to use the value container as cache, so that when a variable is read multiple times, "get handler" is executed only once.Here is an example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;$args&nbsp;$foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$orig_foo&nbsp;$foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$args&nbsp;debug;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"orginal&nbsp;foo:&nbsp;$orig_foo";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"foo:&nbsp;$foo";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Module  <a href="http://wiki.nginx.org/HttpMapModule" target="_blank">ngx_map</a> and its command  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> is new, let me explain. command  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> in Nginx defines the mapping in between two Nginx variables. Back to our example, command  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> defines the mapping from builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> to user variable <code>$foo</code>, in other words, the value of <code>$foo</code> is decided by the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> with the given mapping.
</p>
<p>What exactly our mapping is defined as ?
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;$args&nbsp;$foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p><code>default</code>, found in the first line within curly bracket, defines the default mapping rule. It means if no other rules can be applied, mapping executes the default one, which assigns variable <code>$foo</code> with value <code>0</code>. The second line in the curly bracket defines another rule, which assigns variable <code>$foo</code> with value <code>1</code> when builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> equals to string <code>debug</code>. Therefore, variable <code>$foo</code> is either <code>0</code> or <code>1</code>, up to whether  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> equals to string <code>debug</code>.
</p>
<p>It's cleared enough. Back to our <code>location /test</code>, we saved the value of <code>$foo</code> to another user variable <code>$orig_foo</code> and forcefully overwrite the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> as <code>debug</code>. At last, we print both <code>$orig_foo</code> and <code>$foo</code> using  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>.
</p>
<p>When  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is forcefully overwritten as <code>debug</code>, we might have thought <code>$foo</code> has the value <code>1</code> according to our  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> mappings, but testing defeats us:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;original&nbsp;foo:&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;foo:&nbsp;0<br>
</code><p>As expected, <code>$orig_foo</code> is <code>0</code>, since the request has no URL parameters and  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is empty, our default mapping rule is effective, and <code>$foo</code> gets its value <code>0</code>.
</p>
<p>But the second output appears confusing, as  <a href="http://wiki.nginx.org/HttpCoreModule#args" target="_blank">args</a> is already overwritten as <code>debug</code>, our mapping rule should have assigned variable <code>$foo</code> with value <code>1</code>, what's wrong?
</p>
<p>The reason is simple, when variable <code>$foo</code> is needed the first time, its calculated value from the mapping algorithm is cached, as being said, Nginx module can opt-in to use value container as cache for the outcome of its "get handler". Apparently,  <a href="http://wiki.nginx.org/HttpMapModule" target="_blank">ngx_map</a> caches the outcome to avoid further expensive calculation, so that Nginx can use the cached result for that variable in the subsequent handling for free.
</p>
<p>To verify this, we request again with an URL parameter <code>debug</code>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?debug'<br>
&nbsp;&nbsp;&nbsp;&nbsp;original&nbsp;foo:&nbsp;1<br>
&nbsp;&nbsp;&nbsp;&nbsp;foo:&nbsp;1<br>
</code><p>Granted, the value of <code>$orig_foo</code> becomes <code>1</code>. Since builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> equals <code>debug</code>, according to the mapping rule, variable <code>$foo</code> is calculated as <code>1</code>, and the calculation result is cached and remains as <code>1</code> no matter how  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> will be modified subsequently.
</p>
<p>Command  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> is really more than what it looks, the command actually hooks a "get handler" for user variables, and exposes the script interface so that exact devalue logic can be easily modified by user themselves. The price of doing this, is to restrict the logic be the mapping from one variable to another. Meanwhile, let's recall what we've learnt back in <a href="#01-NginxVariables03">(03)</a>, even if a variable is devalued by a "get handler", it does not necessarily uses a value container as cache, such as the  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> variables.
</p>
<p>Just like module  <a href="http://wiki.nginx.org/HttpMapModule" target="_blank">ngx_map</a>, another builtin module  <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank">ngx_geo</a> uses cache for variables.
</p>
<p>We should have noticed that command  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> is written in front of <code>server</code> directive, i.e. the mappings are defined directly within <code>http</code>. Is it possible to write it within a <code>location</code> directive since it is used only in <code>location /test</code> in our example, the answer is no !
</p>
<p>People who have just learnt Nginx, would argue this global configuration of mappings by  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a>, is likely to be inefficient since request to every <code>location</code> will cause the mapping be repeatedly calculated. Have no worry and let us review, command  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> actually defines a "get handler" for a user variable, the get handler is only executed when the variable needs to be devalued (if cache is used, the handler is executed once for all), therefore, for those requests to certain <code>location</code> which has not used the variable, no calculation will be triggered.
</p>
<p>The technique, which only calculates till the needed moment, is called "lazy evaluation" in computing. "Lazy  evaluation", contrary to "eager evaluation", is not natively supported by most programming languages, a classic one who does is Haskell. In the mini language of Nginx, "eager evaluation" is far more common, such as following statement using  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$b&nbsp;"$a,$a";<br>
</code><p>When variable <code>$b</code> is declared by command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>, the value of <code>$b</code> is computed right away, the calculation won't be delayed till variable <code>$b</code> needs to be devalued.</p>
    <h3 id="01-NginxVariables05">Nginx Variables (05)</h3>
<p>In <a href="#01-NginxVariables02">(02)</a> we learnt that variable life cycle is bounded with the request, but i own you a formal definition of "request". Without further explaining, you might have assumed that "request" refers to the HTTP request initiated by the client. But, there are actually two types of "request" in Nginx world. One is called "main request", the other "subrequest". Now let's wire them in.
</p>
<p>The "main request" is the request initiated by HTTP client from outside Nginx. All requests we've been discussed are "main request", including the internal "jump" introduced in L<vartut 02),="" which="" uses="" command="" <a="" href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec and  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a>
</vartut></p>
<p>Whereas the "subrequest" is a type of cascading request issued by Nginx from within its internals. "Subrequest" is encapsulated just like HTTP request, but it has absolutely nothing to do with HTTP protocol and networking. Subrequest is a useful abstraction in Nginx design, to ease the decomposition of main request into a few "internal requests" with finer granularity. Subrequest can be issued to multiple <code>location</code> interfaces sequentially or in parallel, and handles the main request by collaborating their respective outcomes. Certainly, subrequest can be further decomposed into other subrequests, subrequest can even form a recursive pattern by cascade the request to itself. When a request issues its subrequests, it is called "parent request" in Nginx terminology. As a footnote, for those who had wet themselves with Apache, subrequest is defined equivalently and not totally a stranger.
</p>
<p>Let's check a subrequest example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/bar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;bar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Now in <code>location /main</code>, two subrequests are sent to <code>/foo</code> and <code>/bar</code> via 3rd party module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> and its command  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a>. The subrequests are of type HTTP <code>GET</code>. When they are sent by  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a> the requests are executed sequentially, in the order of their writing, which means, <code>/bar</code> is sub-requested only when <code>/foo</code> has finished its part. And outcome from the subrequests will be concatenated as the final response of <code>/main</code>
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/main'<br>
&nbsp;&nbsp;&nbsp;&nbsp;foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;bar<br>
</code><p>As we can tell, subrequest is issued within a virtual server, i.e. subrequest handling is implemented as a few C API calls, without any networking nor UNIX socket, therefore subrequest execution is extremely fast.
</p>
<p>Back to the very initial subject about Nginx variable life cycle, we can still safely conclude that it is bounded with current request and every request has an isolated copy of variables. However, the request can be "main request" as well as "subrequest". Even if "parent request" and "subrequest" share the same variable name, they are virtually different variables. We can verify it with following test:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;main;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/bar;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"main:&nbsp;$var";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"foo:&nbsp;$var";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;bar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"bar:&nbsp;$var";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>In this test, the same variable <code>$var</code> is declared in <code>location /main</code>, <code>location /foo</code> and <code>location /bar</code> but is initialized with different values. Further more, we print the value of variable <code>$var</code> within <code>/main</code> after two subrequests are handled. Then we issue a request to <code>/main</code>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/main'<br>
&nbsp;&nbsp;&nbsp;&nbsp;foo:&nbsp;foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;bar:&nbsp;bar<br>
&nbsp;&nbsp;&nbsp;&nbsp;main:&nbsp;main<br>
</code><p>Apparently, when the subrequests are handled in <code>/foo</code> and <code>/bar</code>, they both have no impact on the value of <code>$var</code> and the main requesting handling in <code>/main</code>, again subrequests themselves have no impact on each other. So we have asserted that "main request" and every other subrequest each has its own copies of <code>$var</code>.
</p>
<p>Unfortunately, there exists exceptions. Some Nginx module might issue subrequest which references the same copy of variables of their parent request. The 3rd party module <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> is one of them:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;main;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auth_request&nbsp;/sub;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"main:&nbsp;$var";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/sub&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$var&nbsp;sub;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"sub:&nbsp;$var";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Variable <code>$var</code> is declared and initialized with value <code>main</code> in <code>location /main</code> then a subrequest is issued via module <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> and its command <code>auth_request</code>, finally we print variable <code>$var</code> using command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>. Now we reset variable <code>$var</code> as <code>sub</code> in <code>location /sub</code> and check what our test says:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/main'<br>
&nbsp;&nbsp;&nbsp;&nbsp;main:&nbsp;sub<br>
</code><p>It says, <code>$var</code> has become <code>sub</code> back in its main request to <code>location /main</code>, which means the subrequest issued by <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> module shares exactly the same copy of variables with its parent request.
</p>
<p>Wait a minute, you might exclaim, why the print within subrequest to <code>location /sub</code> is missing? good gocha and the answer is simple, command <code>auth_request</code> ignores the responses from its subrequest, instead all it cares is the status code from the subrequest (subrequest is ecapsulated as HTTP request). When status code is <code>2XX</code>, the handling of main request continues, otherwise the handling gets aborted and error is returned. In our example, subrequest only executes a print by  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>, which implicitly returns status code <code>200</code>.
</p>
<p>Surely it's always easier to share variables in between parent request and subrequest, like module <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> does. Do expect the side effect and haunted bugs it consequences when configuration scales and becomes complicated. It's too hard to trace a variable when its value get overwritten in some subrequests. To keep our sanity, modules like  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a>,  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and  <a href="http://wiki.nginx.org/HttpSRCacheModule" target="_blank">ngx_srcache</a> and many other 3rd party module chooses not to share variables in between requests.</p>
    <h3 id="01-NginxVariables06">Nginx Variables (06)</h3>
<p>There are a few subtleties with Nginx builtin variable in the context of subrequest.
</p>
<p>We have learnt from <a href="#01-NginxVariables03">(03)</a>, many builtin variables are not simple value containers, they become special because the variables are hooked with " get/set handler". Even if a value container can be opt-in, it is used as cache to avoid repeated calculations.  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is such a variable, it uses "get/set handler" to calculate the URL parameter string for the current request. When it is a subrequest,  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> should be calculated accordingly and return the subrequest's URL parameter string. We can check it with following example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"main&nbsp;args:&nbsp;$args";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub&nbsp;"a=1&amp;b=2";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/sub&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"sub&nbsp;args:&nbsp;$args";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>We print the value of variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> in <code>location /main</code> by command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>, then we issue a subrequest to <code>location /sub</code> by command  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a>. You might have noticed that the subrequest is given a second parameter, which designates the URL parameters (<code>a=1&amp;b=2</code>). Again in <code>location /sub</code> directive, the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> is printed.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/main?c=3'<br>
&nbsp;&nbsp;&nbsp;&nbsp;main&nbsp;args:&nbsp;c=3<br>
&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;args:&nbsp;a=1&amp;b=2<br>
</code><p>Clearly,  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a> prints <code>c=3</code> in <code>location /main</code>, which is the URL parameter for the main request. And it prints <code>a=1&amp;b=2</code> in <code>location /sub</code>, which is the URL parameter for the subrequest. These are exactly what we were expecting.
</p>
<p>Just like  <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank">$args</a>, builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> is calculated as subrequest's URI in subrequest context.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"main&nbsp;uri:&nbsp;$uri";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/sub&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"sub&nbsp;uri:&nbsp;$uri";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Sending request to <code>location /main</code> we have:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/main'<br>
&nbsp;&nbsp;&nbsp;&nbsp;main&nbsp;uri:&nbsp;/main<br>
&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;uri:&nbsp;/sub<br>
</code><p>The result is what we'd expected.
</p>
<p>Reality is imperfect, not all the builtin variable is calculated from current request, a minority of builtin variables only calculate their values from the main request. Builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a>, provided by module <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank">ngx_http_core</a>, is one of them.
</p>
<p>When variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> is devalued, the HTTP method of "main request" is always obtained. The HTTP method can be <code>GET</code>, <code>POST</code> etc, let's test it:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"main&nbsp;method:&nbsp;$request_method";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/sub&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"sub&nbsp;method:&nbsp;$request_method";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>For this case, variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> is printed in both <code>location /main</code> and <code>location /sub</code>. Subrequest is initiated to <code>location /sub</code> from within <code>location /main</code> by  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a>. Again we use the <code>curl</code> utility to send a <code>POST</code> request to <code>location /main</code>
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;--data&nbsp;hello&nbsp;'http://localhost:8080/main'<br>
&nbsp;&nbsp;&nbsp;&nbsp;main&nbsp;method:&nbsp;POST<br>
&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;method:&nbsp;POST<br>
</code><p>Command <code>curl</code> has a <code>--data</code> option, which designates the request data, meanwhile it lets the request use HTTP method <code>POST</code>. The test shows no surprises, no matter where  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> is devalued, the HTTP method of main request is obtained: <code>POST</code>.
</p>
<p>Hey, would it be the case where variables are devalued and cached for variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> ? so that it is calculated in "main request" and referenced again in the "subrequest" ? Think again. We have learnt back in <a href="#01-NginxVariables05">(05)</a>, each request has its own copies of variables. Module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> fully respects this rule and the subrequest it initiates forbids the variable referencing its counterpart in parent request. So back to our example, even if the calculation has been cached (in fact nothing is cached here), it shall have no impact on the variables on subrequest to <code>location /sub</code>.
</p>
<p>We can adjust our example a little bit, i.e. to print  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a> after the subrequest has been initiated in <code>location /main</code>. This helps answering above question.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"main&nbsp;method:&nbsp;$request_method";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/sub&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"sub&nbsp;method:&nbsp;$request_method";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Test again:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;--data&nbsp;hello&nbsp;'http://localhost:8080/main'<br>
&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;method:&nbsp;POST<br>
&nbsp;&nbsp;&nbsp;&nbsp;main&nbsp;method:&nbsp;POST<br>
</code><p>The result is almost same as before, except the ordering of prints has been reversed for parent request and subrequest. (because we reversed the statements in <code>location /main</code>.
</p>
<p>So we cannot correctly retrieve the HTTP method of subrequest by evaluating  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a>, yet we can use 3rd party module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> and its variable  <a href="http://wiki.nginx.org/HttpEchoModule#.24echo_request_method" target="_blank">$echo_request_method</a> for the purpose.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"main&nbsp;method:&nbsp;$echo_request_method";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_location&nbsp;/sub;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/sub&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"sub&nbsp;method:&nbsp;$echo_request_method";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Finally this is what we'd have wanted:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;--data&nbsp;hello&nbsp;'http://localhost:8080/main'<br>
&nbsp;&nbsp;&nbsp;&nbsp;main&nbsp;method:&nbsp;POST<br>
&nbsp;&nbsp;&nbsp;&nbsp;sub&nbsp;method:&nbsp;GET<br>
</code><p>So parent request prints <code>POST</code>, and subrequest prints <code>GET</code>. Each reflects its own HTTP method.
</p>
<p>Builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank">$request_uri</a>, like  <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank">$request_method</a>, always returns the encoded URL of "main request" no matter the context it is evaluated. This is normal since subrequests are Nginx internal abstractions in which an encoded request URL has no specific meanings.
</p>
<p>If it were the case you would have worried, that builtin variable is cached in between parent request and subrequests, it is as bitter as hell. Since we have already learnt in <a href="#01-NginxVariables05">(05)</a> that module <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> allows its subrequest to share the same copy of variables with its parent request, let's have guts for the following dreadful case:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;map&nbsp;$uri&nbsp;$tag&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/main&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auth_request&nbsp;/sub;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"main&nbsp;tag:&nbsp;$tag";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/sub&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"sub&nbsp;tag:&nbsp;$tag";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Our old friend  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> defines mapping rules from builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> to user variable <code>$tag</code>. The rules are: <code>$tag</code> is 1 if  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> is <code>/main</code>, 2 if it is <code>/sub</code>, 0 for all the other cases. Then subrequest is initiated to <location sub=""> by using module  <a href="http://wiki.nginx.org/HttpAuthRequstModule" target="_blank">ngx_auth_requst</a> and its command <code>auth_request</code>. After the subrequest is handled, variable <code>$tag</code> is printed. Guess what happens on the output if we request to <code>location /main</code> ?
</location></p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/main'<br>
&nbsp;&nbsp;&nbsp;&nbsp;main&nbsp;tag:&nbsp;2<br>
</code><p>eh ? did the mapping rules says <code>$tag</code> is 1 when  <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> is <code>/main</code> ? why it is 2 as if  is requested ?
</p>
<p>Hold on, this is because variable <code>$tag</code> is first devalued in subrequest to <code>/sub</code>, it is mapped as <code>2</code> under that context ( <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank">$uri</a> becomes <code>sub</code>, so mapping rule deducts the value accordingly as <code>2</code>). Mapping result is cached, even worse, the subrequest initiated by <code>auth_request</code> shares the same copy of variables in between parent and subrequests. So Nginx returns the cached value <code>2</code> when variable <code>$tag</code> is devalued back in the parent request. What a big deal.
</p>
<p>Admittedly, think twice if we design to share variables in between parent request and subrequests.</p>
    <h3 id="01-NginxVariables07">Nginx Variables (07)</h3>
<p>We have learnt in <a href="./agentzh's Nginx Tutorials (version 2012.09.28)_files/agentzh's Nginx Tutorials (version 2012.09.28).htm">(01)</a>, that Nginx variables could only be strings. We are in fact, not entirely correct because variables can have non-values. There are 2 kinds of non-values in Nginx, one is "invalid" value, another is "not found" value.
</p>
<p>For example, if Nginx variable <code>$foo</code> is declared but not initialized it has an "invalid" value. Whereas if there exists no <code>XXX</code> parameter in the current request URL, builtin variable <code>$arg_XXX</code> has a "not found" value.
</p>
<p>Nginx special values, such as "invalid" value or "not found" value, are totally different from empty string (""). Like <code>undefined</code> and <code>null</code> found in JavaScript, or <code>nil</code> found in Lua, these non-values are not numerical value <code>0</code>, they are not boolean value <code>false</code> either. In fact the <code>NULL</code> found in SQL is an equivalent element.
</p>
<p>Although back in <a href="./agentzh's Nginx Tutorials (version 2012.09.28)_files/agentzh's Nginx Tutorials (version 2012.09.28).htm">(01)</a>, the uninitialized value becomes empty string in "variable interpolation" via command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>. This is because  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> hooks a "get handler" for the variable it declares, and the handler turns "invalid" value into empty string. Let's review the example in <a href="./agentzh's Nginx Tutorials (version 2012.09.28)_files/agentzh's Nginx Tutorials (version 2012.09.28).htm">(01)</a> for this assertion:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"foo&nbsp;=&nbsp;[$foo]";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$foo&nbsp;32;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"foo&nbsp;=&nbsp;[$foo]";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Again to make it clearer, the <code>server</code> directive is omitted. In this example command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> implicitly declares variable <code>$foo</code> within <code>location /bar</code> Then we print the uninitialized <code>$foo</code> within <code>location /foo</code> by using command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>. The result is following when <code>location /foo</code> was requested:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/foo'<br>
&nbsp;&nbsp;&nbsp;&nbsp;foo&nbsp;=&nbsp;[]<br>
</code><p>If we look at the output, uninitialized variable <code>$foo</code> is equivalent to an empty string. However if we look further into Nginx error log (usually the file name is <code>error.log</code>) it has a warning message when the request is handled:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[warn]&nbsp;5765#0:&nbsp;*1&nbsp;using&nbsp;uninitialized&nbsp;"foo"&nbsp;variable,&nbsp;...<br>
</code><p>How is the warning generated ? The answer is the "get handler" hooked to variable <code>$foo</code> when it is declared by command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>. By the time command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> gets executed within <code>location /foo</code>, it needs to evaluate its parameter <code>"foo = $foo]"</code> this is where "variable interpolation" is happening and variable <code>$foo</code> is devalued, Nginx first checks the value container, which has a special "invalid" value, so it decides to execute the variable's "get handler". The handler prints a warning message in Nginx's error log, then returns and caches an empty string as the value of <code>$foo</code>.
</p>
<p>You might have perceived, this is exactly the same process with which those builtin variable works, when it opt-in a value container as cache. Command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> uses the very mechanism to handle those uninitialized Nginx variables. Be careful though, only special value "invalid" will trigger Nginx to execute its "get handler", another special value "no found" won't.
</p>
<p>The warning message is helpful, as it tells we might have miss spelled variables in Nginx configuration, or we might have used uninitialized variables under an incorrect context. Since cache exists, the warning won't repeat itself for a request life cycle. Besides, the warning can be turned off by module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> and its command  <a href="http://wiki.nginx.org/HttpRewriteModule#uninitialized_variable_warn" target="_blank">uninitialized_variable_warn</a>
</p>
<p>As we said earlier, builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> has a special value "not found" when the request URL has no <code>XXX</code> parameter. However we cannot as easily distinguish it from an empty string, using Nginx native syntax.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"name:&nbsp;[$arg_name]";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>We print variable <code>$arg_name</code> meanwhile not to provide <code>name</code> parameter in the request
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;[]<br>
</code><p>Special value "not found" cannot be asserted in the output, it looks like an empty string. The "variable interpolation" of Nginx simply ignores "not found" when it is evaluated.
</p>
<p>So how do we trace "not found" ? What exactly we can do to distinguish it from an empty string ? Obviously, URL parameter <code>name</code> has an empty string in the request below:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?name='<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;[]<br>
</code><p>We cannot yet tell any differences from the earlier example.
</p>
<p>Good news is, with the help of 3rd party module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a>, it can be done in lua code. Now check example below:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ngx.var.arg_name&nbsp;==&nbsp;nil&nbsp;then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say("name:&nbsp;missing")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say("name:&nbsp;[",&nbsp;ngx.var.arg_name,&nbsp;"]")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>This configuration is pretty close to the earlier one, except we have used module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and its command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a>, to check Nginx variables and their possible special values using lua code. Specifically, we print <code>name: missing</code> if variable <code>$arg_name</code> has a non-value "not found" or "invalid":
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;missing<br>
</code><p>Let me briefly introduce module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a>, the module embeds lua interpreter (standard or <a href="http://luajit.org/luajit.html" target="_blank">LuaJIT</a> in Nginx core, so that lua programs can be executed directly inside Nginx. The lua programs can be written right away in Nginx configuration or be written in external <code>. lua</code> file and loaded via Nginx command referencing the <code>.lua</code> path.
</p>
<p>Back to our example, Nginx variables are referenced by <code>ngx.var</code> from within lua, it is bridged by module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a>. For example, Nginx variable <code>$VARIABLE</code> can be written as  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.var.VARIABLE" target="_blank">ngx.var.VARIABLE</a> in lua code. When Nginx variable <code>$arg_name</code> has non-value (special value "invalid" or "not found"), the corresponding variable <code>ngx.var.arg_name</code> is <code>nil</code> in lua. Further more, module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> provides lua function  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank">ngx.say</a>, functionally it is equivalent to module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> and its command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>.
</p>
<p>Now if we request with <code>name</code> parameter being an empty string, the output becomes different:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?name='<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;[]<br>
</code><p>In this case, Nginx variable <code>$arg_name</code> is an empty string, which is neither "not found" nor "invalid", so Lua code prints empty string "" for <code>ngx.var.arg_name</code>. Apparently we have distinguished it from Lua <code>nil</code>
</p>
<p>The distinction becomes significant in a few scenarios. For example, a web service might filter its returns by <code>name</code> by checking if <code>name</code> parameter exists in URL parameters, even if <code>name</code> has an empty string, it still can be used in a filtering operation.
</p>
<p>Admittedly, there are some restrictions with builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> as we can see from our request to <code>location /test</code>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?name'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;missing<br>
</code><p>In this case, <code>$arg_name</code> is still computed as "not found" non-value, which is counter common sense. Besides,  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a> only resolutes to the first <code>XXX</code> parameter if there are multiple <code>XXX</code> URL parameters, the rest are discarded:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?name=Tom&amp;name=Jim&amp;name=Bob'<br>
&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;[Tom]<br>
</code><p>To fix these defects, one can use module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and its lua function  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.req.get_uri_args" target="_blank">ngx.req.get_uri_args</a> in lua code.</p>
    <h3 id="01-NginxVariables08">Nginx Variables (08)</h3>
<p>In <a href="#01-NginxVariables02">(02)</a> we mentioned that another category of builtin variables  <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank">$cookie_XXX</a> are like  <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank">$arg_XXX</a>. Similarly when there exist no cookie named <code>XXX</code>, its corresponding Nginx variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank">$cookie_XXX</a> has non-value "not found".
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ngx.var.cookie_user&nbsp;==&nbsp;nil&nbsp;then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say("cookie&nbsp;user:&nbsp;missing")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say("cookie&nbsp;user:&nbsp;[",&nbsp;ngx.var.cookie_user,&nbsp;"]")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>The <code>curl</code> utility offers the <code>--cookie name=value</code> option, which designates <code>name=value</code> as a cookie of its request (by adding the <code>Cookie</code> header). Let's test a few cases containing cookies.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;--cookie&nbsp;user=agentzh&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;cookie&nbsp;user:&nbsp;[agentzh]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;--cookie&nbsp;user=&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;cookie&nbsp;user:&nbsp;[]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;cookie&nbsp;user:&nbsp;missing<br>
</code><p>As expected, when cookie <code>user</code> does not exist, Lua variable <code>ngx.var. cookie_user</code> is <code>nil</code>. So we have successfully distinguished the case with empty string and the case with non-value.
</p>
<p>A nice add-on with module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> is when lua references an undeclared variable of Nginx, the variable is <code>nil</code> and Nginx will not aborts it loading as before.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say("$blah&nbsp;=&nbsp;",&nbsp;ngx.var.blah)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>User variable <code>$blah</code> is never declared in the Nginx configuration <code>nginx. conf</code>, but it is referenced as <code>ngx.var.blah</code> in Lua code. Nginx can be started still, because when Nginx loads its configuration, Lua code is only compiled but not executed, So Nginx has no idea a variable <code>$blah</code> is referenced. When lua command is executed in run time by command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a>, the lua variable is evaluated as <code>nil</code>. Module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and its command  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank">ngx.say</a> will convert Lua <code>nil</code> into string <code>"nil"</code> before it is printed, so the output will be:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;$blah&nbsp;=&nbsp;nil<br>
</code><p>This is indeed what we want.
</p>
<p>We should have noticed also, when command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> includes <code>$blah</code> in its parameter, it is never evaluated as "variable interpolation" does (otherwise Nginx will be complaining variable <code>$blah</code> is not declared). This is because command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> does not really support "variable interpolation" . As we have said earlier in <a href="./agentzh's Nginx Tutorials (version 2012.09.28)_files/agentzh's Nginx Tutorials (version 2012.09.28).htm">(01)</a>, Nginx command does not necessarily support "variable interpolation" and it is entirely up to the module implementation.
</p>
<p>It's actually difficult to return an "invalid" non-value. As we learnt in <a href="#01-NginxVariables07">(07)</a>, variables which are declared but not initialized by  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> has non-value "invalid". However, as soon as the variable is devalued, the "get handler" is executed and an empty string is computed and cached, so eventually empty string is returned, not the "invalid" non-value. Following lua code can prove this:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ngx.var.foo&nbsp;==&nbsp;nil&nbsp;then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say("$foo&nbsp;is&nbsp;nil")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.say("$foo&nbsp;=&nbsp;[",&nbsp;ngx.var.foo,&nbsp;"]")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$foo&nbsp;32;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"foo&nbsp;=&nbsp;[$foo]";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>By requesting to <code>location /foo</code> we have:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/foo'<br>
&nbsp;&nbsp;&nbsp;&nbsp;$foo&nbsp;=&nbsp;[]<br>
</code><p>As we can tell, when Lua references uninitialized Nginx variable <code>$foo</code>, it obtains empty string.
</p>
<p>Last not the least, we should have pointed out, although Nginx variable can have only strings as valid value. The 3rd party module  <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank">ngx_array_var</a> can support array like operations for Nginx variable.Here is an example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array_split&nbsp;","&nbsp;$arg_names&nbsp;to=$array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array_map&nbsp;"[$array_it]"&nbsp;$array;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array_join&nbsp;"&nbsp;"&nbsp;$array&nbsp;to=$res;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$res;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Module  <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank">ngx_array_var</a> provides commands <code>array_split</code>, <code>array_map</code> and <code>array_join</code>. The semantics is pretty close to the builtin functions <code>split</code>, <code>map</code> and <code>join</code> in Perl (other languages support similar functionalities too). Now let's check what happens when <code>location /test</code> is requested:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test?names=Tom,Jim,Bob<br>
&nbsp;&nbsp;&nbsp;&nbsp;[Tom]&nbsp;[Jim]&nbsp;[Bob]<br>
</code><p>Clearly module  <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank">ngx_array_var</a> make it easier to handle inputs with variable length, such as the URL parameter <code>name</code>, which composes of multiple comma delimited names. Still we must emphasize, module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> is a much better choice to execute this kind of complicated tasks, usually it is more flexible and maintainable.
</p>
<p>Till now the tutorial covers the Nginx variable. In the process we have been discussing many builtin and 3rd party Nginx modules, these modules help us better understand features and internals of Nginx variable by composing various mini constructs. Later on the tutorial will be covering more details of those modules.
</p>
<p>With these examples, we should understand that Nginx variable plays a key role in the Nginx mini language: variables are the ways and means Nginx communicate internally, they contain all the needed information (including the request information) and they are the cornerstone elements which bridge every other Nginx modules. Nginx variables are everywhere in the coming tutorials, understand them is absolutely necessary.
</p>
<p>In the coming tutorial "<a href="#02-NginxDirectiveExecOrder01">Nginx Directive Execution Order</a>", we will be discussing in detail the Nginx execution ordering and the phases every request traverses. It' s indispensable to understand them since for the Nginx mini language, the ordering of writing can be dramatically different from the ordering of executing in the timeline. It usually confuses many Nginx users.</p>
    <h3 id="02-NginxDirectiveExecOrder01">Nginx directive execution order (01)</h3>
<p>It can be really frustrated for many Nginx users, that if multiple Nginx module's commands are written within one <code>location</code> directive, the execution order can be very different from the order they were written. For those impatient who choose "try out possibilities before everything else", the directive commands can be scattered like a hell. This series is to uncover the mysteries and help you better understand the execution ordering behind the scene.
</p>
<p>We start with a confused example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;56;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Clearly, we'd expect to output <code>32</code>, followed by <code>56</code>. Because variable <code>$a</code> has been reset after command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> "is executed". Really? you are welcomed to the reality:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;56<br>
&nbsp;&nbsp;&nbsp;&nbsp;56<br>
</code><p>Wow, statement <code>set $a 56</code> must have had been executed before the first <code>echo $a</code> command, but why? Is it a Nginx bug ?
</p>
<p>There ain't any Nginx bug here, or we'd rather rephrase it as a feature, and it's a long story. When Nginx handles every request, the execution follows a few predefined phases.
</p>
<p>There can be altogehter 11 phases when Nginx handles a request, let's start with three most common ones: <code>rewrite</code>, <code>access</code> and <code>content</code> (later on the other phases will be addressed)
</p>
<p>Usually a Nginx module and its commands register their execution in only one of those phases. For example command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> runs in phase <code>rewrite</code>, and command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> runs in phase <code>content</code>. Since phase <code>rewrite</code> occurs before phase <code>content</code> for every request processing, its commands are executed earlier as well. Therefore, command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> always gets executed before command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> within one <code>location</code> directive, regardless of their statement ordering in the configuration.
</p>
<p>Back to our example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;56;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br>
</code><p>The actual execution ordering is:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;56;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br>
</code><p>It's clear now, two commands  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> are executed in phase <code>rewrite</code>, two commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> are executed afterwards in phase <code>content</code>. Commands belonging to different phases cannot be executed back and forth.
</p>
<p>To prove ourselves and better uncover these points, We can troubleshoot Nginx's "debug log".
</p>
<p>We've not checked Nginx "debug log" before, so let's briefly introduce its usage."debug log" by default is disabled, because it has very big runtime overheads and overall Nginx service is degraded. To enable "debug log" we would need to reconfigure and recompile Nginx binary, by giving <code>--with-debug</code> option for the package's <code>./configure</code> script. The typical steps are as following when build under Linux or Mac OS X from source:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;tar&nbsp;xvf&nbsp;nginx-1.0.10.tar.gz<br>
&nbsp;&nbsp;&nbsp;&nbsp;cd&nbsp;nginx-1.0.10/<br>
&nbsp;&nbsp;&nbsp;&nbsp;./configure&nbsp;--with-debug<br>
&nbsp;&nbsp;&nbsp;&nbsp;make<br>
&nbsp;&nbsp;&nbsp;&nbsp;sudu&nbsp;make&nbsp;install<br>
</code><p>In case the package <a href="http://openresty.org/" target="_blank">ngx_openresty</a> is used. The option <code>--with-debug</code> can be used with its <code>./configure</code> script as well.
</p>
<p>After we rebuild the Nginx debug binary with <code>--with-debug</code> option, we still need to explicitly use the <code>debug</code> log level (it's the lowest level) for command  <a href="http://wiki.nginx.org/CoreModule#error_log" target="_blank">error_log</a>, in Nginx configuration:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;error_log&nbsp;logs/error.log&nbsp;debug;<br>
</code><p><code>debug</code>, the second parameter of command  <a href="http://wiki.nginx.org/CoreModule#error_log" target="_blank">error_log</a> is crucial. Its first parameter is error log's file path, <code>logs/error.log</code>. Certainly we can use another file path but do remember the location because we need to check its content right away.
</p>
<p>Now let's restart Nginx (Attention, it's not enough to reload Nginx. It needs to be killed and restarted because we've updated the Nginx binary). Then we can send the request again:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;56<br>
&nbsp;&nbsp;&nbsp;&nbsp;56<br>
</code><p>It's time to check Nginx's error log, which is becoming a lot more verbose (more than 700 lines for the request in my setup). So let's apply the <code>grep</code> command to filter what we would be interested:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;grep&nbsp;-E&nbsp;'http&nbsp;(output&nbsp;filter|script&nbsp;(set|value))'&nbsp;logs/error.log<br>
</code><p>It's approximately like below (for clearness, I've edited the <code>grep</code> output and remove its timestamp etc) :
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;"32"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;"56"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;output&nbsp;filter&nbsp;"/test?"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;output&nbsp;filter&nbsp;"/test?"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;output&nbsp;filter&nbsp;"/test?"<br>
</code><p>It barely makes any senses, does it? So let me interpret. Command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> dumps two lines of debug info which start with <code>http script</code>, the first line tells the value which command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> has possessed, and the second line being the variable name it will be given to, so for the leading filtered log:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;"32"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br>
</code><p>These two lines are generated by this statement:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br>
</code><p>And for the following filtered log:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;"56"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br>
</code><p>They are generated by this statement:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;56;<br>
</code><p>Besides, whenever Nginx outputs its response, its "output filter" will be executed, our favorite command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> is no exception. As soon as Nginx's "output filter" is executed, it generates debug log like below:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;5363#0:&nbsp;*1&nbsp;http&nbsp;output&nbsp;filter&nbsp;"/test?"<br>
</code><p>Of course the debug log might not have <code>"/test?"</code>, since this part corresponds to the actual request URI. By putting everything together, we can finally conclude those two commands  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> are indeed executed before the other two commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>.
</p>
<p>Considerate readers must have noticed that there are three lines of <code>http output filter</code> debug log but we were having only two output commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>. In fact, only the first two debug logs are generated by the two  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> statements. The last debug log is added by module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> because it needs to flag the end of output. The flag operation itself causes Nginx's "output filter" to be executed again. Many modules including  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> has similar behavior, when they need to give output data.
</p>
<p>All right, there are no surprises with those duplicated <code>56</code> outputs. We are not given a chance to execute  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> in front of the second  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> command. Luckily, we can still achieve this with a few techniques:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$saved_a&nbsp;$a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;56;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$saved_a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Now we have what we have wanted:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;32<br>
&nbsp;&nbsp;&nbsp;&nbsp;56<br>
</code><p>With the help of another user variable <code>$saved_a</code>, the value of <code>$a</code> is saved before it is overwritten. Be careful, the execution order of multiple  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> commands are ensured to be like their order of writing by module <ngx_rewrite>. Similarly, module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> ensures multiple  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> commands get executed in the same order of their writing.
</ngx_rewrite></p>
<p>If we recall examples in <a href="./agentzh's Nginx Tutorials (version 2012.09.28)_files/agentzh's Nginx Tutorials (version 2012.09.28).htm">Nginx Variables</a>, this technique has been applied extensively. It bypasses the execution ordering difficulties introduced by Nginx phased processing.
</p>
<p>You might need to ask : "how would I know the phase a Nginx command belongs to ?" Indeed, the answer is RTFD. (Surely advanced developers can examine the C source code directly). Many module marks explicitly its applicable phase in the module's documentation, such as command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> writes below in its documentation:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;phase:&nbsp;content<br>
</code><p>It says the command is executed in phase <code>content</code>. If you encounters a module which misses the applicable phase in the document, you can write to its authors right away and ask for it. However, we shall be reminded, not every command has an applicable phase. Examples are command  <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank">geo</a> introduced in <a href="./agentzh's Nginx Tutorials (version 2012.09.28)_files/agentzh's Nginx Tutorials (version 2012.09.28).htm">Nginx Variables (01)</a> and command  <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank">map</a> introduced in <a href="#01-NginxVariables04">Nginx Variables (04)</a>. These commands, who have no explicit applicable phase, are declarative and unrelated to the conception of execution ordering. Igor Sysoev, the author of Nginx, has made the statements a few times publicly, that Nginx mini language in its configuration is "declarative" not "procedural".</p>
    <h3 id="02-NginxDirectiveExecOrder02">Nginx directive execution order (02)</h3>
<p>We've just learnt, all  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> commands within <code>location</code> are executed in <code>rewrite</code> phase. In fact, almost all commands implemented by module <code>rewrite</code> are executed in <code>rewrite</code> phase under the specific context. Commad  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> introduced in <a href="#01-NginxVariables02">Nginx Variables (02)</a> is one of them. However, we shall point out that when these commands are found in <code>server</code> directive, they will be executed in an earlier phase we've not addressed: the <code>server rewrite</code> phase.
</p>
<p>Command  <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank">set_unescape_uri</a>, introduced in <a href="#01-NginxVariables02">Nginx Variables (02)</a> is also executed in <code>rewrite</code> phase. Actually, commands implemented by module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a> can mix with commands implemented by module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> and the execution ordering is ensured. Let's check an example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;"hello%20world";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_unescape_uri&nbsp;$b&nbsp;$a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$c&nbsp;"$b!";<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$c;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>By sending a request accordingly we have:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;world!<br>
</code><p>Apparently, the  <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank">set_unescape_uri</a> command and its neighboring  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> commands are all executed in the order of their writing.
</p>
<p>To further demonstrate our assertion, we check again Nginx "debug log" (in case it's unclear for you how to check "debug log", please reference steps found in <a href="#02-NginxDirectiveExecOrder01">(01)</a>).
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;grep&nbsp;-E&nbsp;'http&nbsp;script&nbsp;(value|copy|set)'&nbsp;logs/error.log<br>
</code><p>The debug logs are filtered as:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;"hello%20world"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value&nbsp;(post&nbsp;filter):&nbsp;"hello&nbsp;world"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$b<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;copy:&nbsp;"!"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$c<br>
</code><p>The leading two lines:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value:&nbsp;"hello%20world"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$a<br>
</code><p>They correspond to the command
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;"hello%20world";<br>
</code><p>The following two lines:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;value&nbsp;(post&nbsp;filter):&nbsp;"hello&nbsp;world"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$b<br>
</code><p>They are generated by command
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set_unescape_uri&nbsp;$b&nbsp;$a;<br>
</code><p>There are minor differences in the first line, if we compare to the logs generated by command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>: the <code>"(post filter)"</code> addition. In the end of the line, URL decoding has successfully executed as we wish. <code>"hello%20world"</code> is decoded as <code>"hello world"</code>.
</p>
<p>The last two lines of debug log:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;copy:&nbsp;"!"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;11167#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$c<br>
</code><p>They are generated by the last  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> command
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$c&nbsp;"$b!";<br>
</code><p>As you might have noticed, since "variable interpolation" is evaluated when variable <code>$c</code> is declared and initialized, the debug log starts with <code>http script copy</code>. In the end of the log it is the string constant <code>"!"</code> to be concatenated.
</p>
<p>With the log information, it's fairly easy to tell the command execution ordering:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;"hello%20world";<br>
&nbsp;&nbsp;&nbsp;&nbsp;set_unescape_uri&nbsp;$b&nbsp;$a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$c&nbsp;"$b!";<br>
</code><p>It is a perfect match to the statements ordering.
</p>
<p>Just like the commands implemented in module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a>, command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> implemented in 3rd party module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a>, can mix with commands of module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> as well. As introduced in <a href="#01-NginxVariables07">Nginx Variables (07)</a>, command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> supports computation with given Lua code, and assigns the computed result to a Nginx variable. As command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> does, command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> declares Nginx variable before initialization if the variable does not exist.
</p>
<p>Let's check a mixed example which comprises command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> and  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$b&nbsp;56;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_by_lua&nbsp;$c&nbsp;"return&nbsp;ngx.var.a&nbsp;+&nbsp;ngx.var.b";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$equation&nbsp;"$a&nbsp;+&nbsp;$b&nbsp;=&nbsp;$c";<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$equation;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Variable <code>$a</code> and <code>$b</code> are initialized with numerical value <code>32</code> and <code>56</code> respectively, then command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> is used together with given Lua code to compute the sum of <code>$a</code> and <code>$b</code>. Variable <code>$c</code> is initialized with the computed value. Finally, variables <code>$a</code>, <code>$b</code> and <code>$c</code> are concatenated by "variable interpolation" and assigns the result to variable <code>$equation</code>, which is printed by command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>.
</p>
<p>We shall pay attention to a few points in the example: Firstly Nginx variable <code>$VARIABLE</code> is referenced as  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.var.VARIABLE" target="_blank">ngx.var.VARIABLE</a> in Lua code. Secondly, since Nginx variables are strings, the value of variable <code>ngx.var.a</code> and <code>ngx.var.b</code> are actually strings <code>"32"</code> and <code>"56"</code>, however they are automatically converted to numerical values by Lua in the addition operation. Thirdly Lua code returns to Nginx variable <code>$c</code> the computed sum value by statement <code>return</code>. Finally when Lua code returns, it actually converts the numerical value back to string. (because string is the only valid value for Nginx variable)
</p>
<p>The actual output meets our expectation:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;+&nbsp;56&nbsp;=&nbsp;88<br>
</code><p>This in fact asserts that command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> can mix with commands implemented by module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a>, such as  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>.
</p>
<p>Many other 3rd party modules support the mix with module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> as well. The examples include module  <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank">ngx_array_var</a>, discussed in <a href="#01-NginxVariables08">Nginx Variables (08)</a> and module  <a href="http://wiki.nginx.org/HttpEncryptedSessionModule" target="_blank">ngx_encrypted_session</a>, which encrypts sessions. The latter will be studied in detail shortly.
</p>
<p>Since builtin module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> is virtually indispensable, it's a great advantage for the 3rd party module has the caliber of being mixed with. Truth is, all of those 3rd party modules have adopted a special technique, which allows the "injection" of their execution into commands of module <code>rewrite</code> (with the help of a 3rd party module <a href="https://github.com/simpl/ngx_devel_kit" target="_blank">ngx_devel_kit</a> developed by Marcus Clyne). For the rest regular 3rd party modules, which also register their execution in phase <code>rewrite</code>, their commands are executed separately from module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> in runtime. In fact, it's hardly accurate to tell the commands execution ordering in between different modules (strictly speaking they are usually executed in the order of loading, but exception does exist). For example both modules, <code>A</code> and <code>B</code> register their commands to be executed in phase <code>rewrite</code>, then it is either the case in which commands of <code>A</code> are executed followed by <code>B</code> or the other complete way around. Unless it is explicitly documented, we cannot rely on the uncertain ordering in our configurations.</p>
    <h3 id="02-NginxDirectiveExecOrder03">Nginx directive execution order  (03)</h3>
<p>As discussed earlier, unless special techniques are utilized as module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a> does, a module can not mix its commands with  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a>, and expects the correct execution order. Even if the commands are registered in the <code>rewrite</code> phase as well. We can demonstrate with some examples.
</p>
<p>3rd party module  <a href="http://wiki.nginx.org/HttpHeadersMoreModule" target="_blank">ngx_headers_more</a> provides a few commands, which deal with the current request header and response header. One of them is  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_header" target="_blank">more_set_input_header</a>. The command can modify a given request header in <code>rewrite</code> phase (or add the specific header if it's not available in current request). As described in its documentation, the command always executes in the end of <code>rewrite</code> phase:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;phase:&nbsp;rewrite&nbsp;tail<br>
</code><p>Being terse though, <code>rewrite tail</code> means the end of phase <code>rewrite</code>.
</p>
<p>Since it executes in the end of phase <code>rewrite</code>, the implication is its execution is always after the commands implemented in module <code>ngx_rewrite</code>. Even if it is written at the very beginning:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$value&nbsp;dog;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;more_set_input_headers&nbsp;"X-Species:&nbsp;$value";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$value&nbsp;cat;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"X-Species:&nbsp;$http_x_species";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>As briefly introduced in <a href="#01-NginxVariables02">Nginx Variables (02)</a>, Builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24http_HEADER" target="_blank">$http_XXX</a> has the header <code>XXX</code> for the current request. We must be careful though, variable &lt;$http_XXX&gt; matches to the normalized request header, i.e. it lower cases capital letters and turns minus <code>-</code> into underscore <code>_</code> for the request header names. Therefore variable <code>$http_x_species</code> can successfully catches the request header <code>X-Species</code>, which is declared by command  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_header" target="_blank">more_set_input_header</a>.
</p>
<p>Because of the statement ordering, we might have mistakenly concluded header <code>X-Species</code> has the value <code>dog</code> when <code>/test</code> is requested. But the actual result is different:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;X-Species:&nbsp;cat<br>
</code><p>Clearly, statement <code>set $value cat</code> is executed earlier than  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank">more_set_input_headers</a>, although it is written afterwards.
</p>
<p>This example tells us that commands of different modules are executed independently from each other, even if they are all registered in the same processing phase. (unless it is implemented as module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a>, whose commands are specifically tuned with module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a>). In other words, every processing phase is further divided into sub-phases by Nginx modules.
</p>
<p>Similar to  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank">more_set_input_headers</a>, command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> provided by 3rd party module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> execute in the end of <code>rewrite</code> phase as well. We can verify this:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite_by_lua&nbsp;"ngx.var.a&nbsp;=&nbsp;ngx.var.a&nbsp;+&nbsp;1";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;56;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$a;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>By using Lua code specified by command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> Nginx variable <code>$a</code> is incremented by 1.We might have expected the result be <code>56</code> if we are looking at the writing sequence.The actual result is <code>57</code> because command <ngx_lua rewrite_by_lua=""> is always executed after all the  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> statements.
</ngx_lua></p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;57<br>
</code><p>Admittedly command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> has different behavior than command  <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a>, which is discussed in <a href="#02-NginxDirectiveExecOrder02">(02)</a>.
</p>
<p>Out of sheer curiosity, we shall ask immediately that what would be execution ordering in between  <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank">more_set_input_headers</a> and  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a>, since they both ride on <code>rewrite</code> tail? The answer is : undefined. We must avoid a configuration which relies on their execution orders.
</p>
<p>Nginx phase <code>rewrite</code> is a rather early processing phase. Usually commands registered in this phase execute various rewrite tasks on the request (for example rewrite the URL or the URL parameters), the commands might also declare and initialize Nginx variables which are needed in the subsequent handling. Certainly, one cannot forbid others to complicate themselves by checking the request body, or visit a database etc. After all, command like  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> offers the caliber to stuff in any potentially mind twisted Lua code.
</p>
<p>After phase <code>rewrite</code>, Nginx has another phase called <code>access</code>. The commands provided by 3rd party module <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a>, which is discussed in <a href="#01-NginxVariables05">Nginx Variables (05)</a>, execute in phase <code>access</code>. Commands registered in <code>access</code> phase mostly carry out ACL functionalities, such as guarding user clearance, checking user origins, examining source IP validity etc.
</p>
<p>For example command  <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank">allow</a> and  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> provided by builtin module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> can control which IP addresses have the privileges to visit, or which IP addresses are rejected:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/hello&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow&nbsp;127.0.0.1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"hello&nbsp;world";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Location <code>/hello</code> allows visit from localhost (IP address <code>127.0.0.1</code>) and reject requests from all other IP addresses (returns http error <code>403</code>) The rules defined by  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> commands are asserted in the writing sequence. Once one rule is matched, the assertion stops and all the rest  <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank">allow</a> or  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> commands are ignored. If no rule is matched, handling continues in the following statements. If the matched rule is  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a>, handing is aborted and error <code>403</code> is returned immediately. In our example, request issued from localhost matches to the rule <code>allow 127.0.0.1</code> and handing continues to the other statements, however request issued from every other IP addresses will match rule <code>deny all</code> handling is therefore aborted and error <code>403</code> is returned.
</p>
<p>We can give it a test, by sending request from localhost:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/hello'<br>
&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;world<br>
</code><p>If request is sent from another machine (suppose Nginx runs on IP <code>192.168.1.101</code> ) we have:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://192.168.1.101:8080/hello'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;html&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;&lt;title&gt;403&nbsp;Forbidden&lt;/title&gt;&lt;/head&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&nbsp;bgcolor="white"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;center&gt;&lt;h1&gt;403&nbsp;Forbidden&lt;/h1&gt;&lt;/center&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/html&gt;<br>
</code><p>By the way, module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> supports the "CIDR notation" to designate a sub-network. For example <code>169.200.179.4/24</code> represents the sub-network which has the routing prefix <code>169.200.179.0</code> (or subnet mask <code>255.255. 255.0</code>)
</p>
<p>Because commands of module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> execute in <code>access</code> phase, and phase <code>access</code> is behind <code>rewrite</code> phase. So for those commands we have been discussing, regardless of the writing order they always execute in <code>rewrite</code> phase, which is earlier than  <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank">allow</a> or  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a>. Keep this in mind, we shall try our best to keep the writing and execution order consistent.</p>
    <h3 id="02-NginxDirectiveExecOrder04">Nginx directive execution order (04)</h3>
<p>Module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> implements another command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a>. The command allows lua code to be executed in the end of <code>access</code> phase, which means it always executes after  <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank">allow</a> and  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> even they belong to the same phase. In many cases, we examine the request' s source IP address with  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a>, and use command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> to execute more complicated verifications with Lua. For example by querying a database or other backend services, the current user's identity and privileges are examined.
</p>
<p>We can check a simple example, which uses command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> to implement the IP filtering functionality of module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a>
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/hello&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;ngx.var.remote_addr&nbsp;==&nbsp;"127.0.0.1"&nbsp;then<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ngx.exit(403)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"hello&nbsp;world";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Nginx's builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> is referenced in Lua to get the client's IP address. Then Lua statement <code>if</code> is used to determine if the address equals <code>127.0.0.1</code>. Lua returns if it equals, Nginx thus continues the subsequent handling (including the <code>content</code> phase where command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> applies to). If it is not the localhost address, current handling is aborted by using  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> module's Lua function  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.exit" target="_blank">ngx.exit</a> Client gets a http error <code>403</code>.
</p>
<p>The example is equivalent to the other example using  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> module in terms of functionality, which was discussed in <a href="#02-NginxDirectiveExecOrder03">(03)</a>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/hello&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allow&nbsp;127.0.0.1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"hello&nbsp;world";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>However we shall point out, performance wise the two still have differences. Module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> performs better because it is specifically implemented as a Nginx module in C.
</p>
<p>We can measure the performance differences of the two. After all, performance is what we are after by using Nginx. On the other hand, it's absolutely necessary to be equipped with measuring techniques, because only actual data distinguishes amateurs and professionals. In fact, both  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> perform pretty good for IP filtering. To minimize measuring errors we could measure directly the elapsed time of <code>access</code> phase. Traditionally, this means hacking Nginx source code with timing code and statistical code, or recompile Nginx binary so that it can be monitored by specific profiling tools like <code>GNU gprof</code>.
</p>
<p>We are lucky, because current releases of Solaris, Mac OSX or FreeBSD offer a system utility <code>dtrace</code>, which allows micro monitoring of user process in terms of performance (and functionality as well). The tool spares us from hacking source code or recompilation with profiling. Let's demonstrate the measuring scenario on the MacBook Air because <code>dtrace</code> is available since Mac OS X 10.5
</p>
<p>First, open the Terminal application of Mac OSX, change to your preferable path and create a file named as <code>nginx-access-time.d</code>, edit the file with following content:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;#!/usr/bin/env&nbsp;dtrace&nbsp;-s<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;pid$1::ngx_http_handler:entry<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elapsed&nbsp;=&nbsp;0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;pid$1::ngx_http_core_access_phase:entry<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin&nbsp;=&nbsp;timestamp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;pid$1::ngx_http_core_access_phase:return<br>
&nbsp;&nbsp;&nbsp;&nbsp;/begin&nbsp;&gt;&nbsp;0/<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elapsed&nbsp;+=&nbsp;timestamp&nbsp;-&nbsp;begin;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin&nbsp;=&nbsp;0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;pid$1::ngx_http_finalize_request:return<br>
&nbsp;&nbsp;&nbsp;&nbsp;/elapsed&nbsp;&gt;&nbsp;0/<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@elapsed&nbsp;=&nbsp;avg(elapsed);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elapsed&nbsp;=&nbsp;0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Save the file and make it executable.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;chmod&nbsp;+x&nbsp;./nginx-access-time.d<br>
</code><p>The <code>.d</code> file actually contains code written in <code>D</code> language offered by utility <code>dtrace</code> (attention, the <code>D</code> language is not the other <code>D</code> language, which is advocated by Walter Bright for a better C++). So far we cannot really explain in detail the code because it requires a thorough understanding of Nginx internals. Anyway we shall be clear of the code's purpose: measure requests being handled by specific Nginx worker process and calculate the average time elapsed in <code>access</code> phase.
</p>
<p>Now we can get the <code>D</code> script running. The script takes a command line parameter, which is the process id (pid) of Nginx worker. Since Nginx supports multiple worker processes and the requests can be randomly handled by anyone of them, we'd like to configure Nginx in its configuration <code>nginx.conf</code> so that only one worker is requested.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;worker_processes&nbsp;1;<br>
</code><p>After Nginx binary is restarted, the worker process id can be obtained by command <code>ps</code>.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;ps&nbsp;ax|grep&nbsp;nginx|grep&nbsp;worker|grep&nbsp;-v&nbsp;grep<br>
</code><p>Typically we have:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;10975&nbsp;&nbsp;&nbsp;?&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:34.28&nbsp;nginx:&nbsp;worker&nbsp;process<br>
</code><p><code>10975</code> is my Nginx worker pid. In case you have multiple lines, you must have started multiple Nginx server instances or the current Nginx server has started multiple worker processes.
</p>
<p>Then as root, script <code>nginx-access-time.d</code> is executed with the worker pid
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;sudo&nbsp;./nginx-access-time.d&nbsp;10975<br>
</code><p>We shall have one output message if everything goes OK.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;dtrace:&nbsp;script&nbsp;'./nginx-access-time.d'&nbsp;matched&nbsp;4&nbsp;probes<br>
</code><p>The message says our <code>D</code> script has successfully deployed 4 probes on the target process. Then the script is ready to trace process <code>10975</code> constantly.
</p>
<p>Let's open another Terminal, and send multiple requests with <code>curl</code> to our monitored process
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/hello'<br>
&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;world<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/hello'<br>
&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;world<br>
</code><p>Back to our Terminal where <code>D</code> script is running, press keys <code>Ctrl-C</code> to interrupt it. When the script bails out it prints on console the statistical result. For example my console has following result:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;sudo&nbsp;./nginx-access-time.d&nbsp;10975<br>
&nbsp;&nbsp;&nbsp;&nbsp;dtrace:&nbsp;script&nbsp;'./nginx-access-time.d'&nbsp;matched&nbsp;4&nbsp;probes<br>
&nbsp;&nbsp;&nbsp;&nbsp;^C<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19219<br>
</code><p>The final <code>19219</code> is the average time elapsed in <code>access</code> phase in nano seconds (1 second = 1000x1000x1000 nano seconds)
</p>
<p>Done with the steps. We can run the <code>nginx-access-time.d</code> script to calculate average elapsed time in phase <code>access</code> for three different Nginx setups respectively. They are IP filtering with module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a>, IP filtering with command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a>, and finally no filtering for <code>access</code> phase. The last result helps eliminate the side effect caused by probes or other "systematic errors". Besides, we can use traffic loader tools such as <code>ab</code> to sends half a million requests to minimize "random errors", as below:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;ab&nbsp;-k&nbsp;-c1&nbsp;-n100000&nbsp;'http://127.0.0.1:8080/hello'<br>
</code><p>Therefore the statistical result of <code>D</code> script is as close as possible to the "actual" time.
</p>
<p>In the Mac OSX, a typical run has following results:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ngx_access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18146<br>
&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35011<br>
&nbsp;&nbsp;&nbsp;&nbsp;no&nbsp;filtering&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15887<br>
</code><p>We minus the last value from the former two:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;ngx_access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2259<br>
&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19124<br>
</code><p>Well, module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> out performs command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> by a magnitude, as we might have expected. Still the absolute difference is tiny. For the <code>Intel Core2Due 1.86 GHz</code> CPU of mine, there is only a few micro seconds.
</p>
<p>In fact the  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> example can be further optimized using builtin variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24binary_remote_addr" target="_blank">$binary_remote_addr</a>. This variable has the IP address in binary form whereas variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> has the address in a longer string format. Shorter address can be compared quicker when Lua executes its string operations.
</p>
<p>Be careful, if "debug log" is enabled as introduced in <a href="#02-NginxDirectiveExecOrder01">(01)</a> the computed elapsed time will increase dramatically, because "debug log" has a huge overhead.</p>
    <h3 id="02-NginxDirectiveExecOrder05">Nginx directive execution order (05)</h3>
<p><code>content</code> is by all means the most significant phase in Nginx's request handling, because commands running in the phase have the responsibility to generate "content" and output HTTP response. Because of its importance, Nginx has a rich set of commands running in it. The commands include  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>,  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a>,  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a>,  <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank">echo_location</a>,  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a>, which were discussed in <a href="#01-NginxVariables02">Nginx Variables (02)</a>, <a href="#01-NginxVariables03">Nginx Variables (03)</a>, <a href="#01-NginxVariables05">Nginx Variables (05)</a> and <a href="#01-NginxVariables07">Nginx Variables (07)</a> respectively.
</p>
<p><code>content</code> is a phase which runs later than <code>rewrite</code> and <code>access</code>. Therefore its commands always execute in the end when they are used together with commands of <code>rewrite</code> and <code>access</code>.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;rewrite&nbsp;phase<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$age&nbsp;1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite_by_lua&nbsp;"ngx.var.age&nbsp;=&nbsp;ngx.var.age&nbsp;+&nbsp;1";<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;access&nbsp;phase<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;10.32.168.49;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;"ngx.var.age&nbsp;=&nbsp;ngx.var.age&nbsp;*&nbsp;3";<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;content&nbsp;phase<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"age&nbsp;=&nbsp;$age";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>This is a perfect example, in which commands are executed in an exact sequence as they are written. The testing result matches to our expectations too.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;=&nbsp;6<br>
</code><p>In fact, the commands' writing order can be completely shuffled and it won't have any impact to their execution sequence. Command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>, which is implemented by module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a>, executes in <code>rewrite</code> phase. Command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> from module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> executes in the end of <code>rewrite</code> phase. Command  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> from module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> executes in <code>access</code> phase. Command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> from module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> executes in the end of <code>access</code> phase. Finally, our favorite command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a>, implemented by module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a>, executes in <code>content</code> phase.
</p>
<p>The example also demonstrates the collaborating in between commands running on each different Nginx phase. In the process, Nginx variable is the data carrier interconnecting commands and modules. The execution order of these commands is largely decided by the phase each applies to.
</p>
<p>As matter of fact, multiple commands from different modules could coexist in phase <code>rewrite</code> and <code>access</code>. As the example shows, command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> and command  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a> both belong to phase <code>rewrite</code>. Command  <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank">deny</a> and command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> both belong to phase <code>access</code>. However it is not the same story for phase <code>content</code>.
</p>
<p>Most modules, when they implement commands for phase <code>content</code>, they are actually inserting "content handler" for the current <code>location</code> directive, however there can be one and only one "content handler" for a <code>location</code>. So only one module could beat the rest when multiple modules are contending the role. Consider following problematic example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;hello;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'ngx.say("world")';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> from module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> and command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> from module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> both execute in phase <code>content</code>. But only one of them could successfully become "content handler":
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;world<br>
</code><p>Our test indicates, that the winner is  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> although it is written afterwards, and command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> never really has a chance to run. We cannot be assured which module wins in the circumstance. For example, module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> wins and the output becomes <code>hello</code> if we swap the  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> and  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> statements. So we shall avoid to use multiple commands for phase <code>content</code>, if the commands are implemented by different modules.
</p>
<p>The example can be modified by replacing command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> with command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> and we will get what we need:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;hello;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;world;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Again test proves:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;hello<br>
&nbsp;&nbsp;&nbsp;&nbsp;world<br>
</code><p>We can use multiple  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> commands, there is no problem with this because they all belong to module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a>. Module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> regulates the execution ordering of them. Be careful though, not every module supports the commands being executed multiple times within one <code>location</code>. Command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> for an instance, can be used only once, so following example is incorrect:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'ngx.say("hello")';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'ngx.say("world")';<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Nginx dumps error for the configuration:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[emerg]&nbsp;"content_by_lua"&nbsp;directive&nbsp;is&nbsp;duplicate&nbsp;...<br>
</code><p>The correct way of doing it is:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content_by_lua&nbsp;'ngx.say("hello")&nbsp;ngx.say("world")';<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Instead of using twice the  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a> command in <code>location</code>, the approach is to call function  <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank">ngx.say</a> twice in the Lua code, which is executed by command  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a>
</p>
<p>Similarly, command  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a> from module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> cannot coexist with command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> within one <code>location</code> because they both execute in <code>content</code> phase. Many Nginx newbies make following mistake:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"before...";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;http://127.0.0.1:8080/foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"after...";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"contents&nbsp;to&nbsp;be&nbsp;proxied";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>The example tries to output strings <code>"before..."</code> and <code>"after..."</code> with command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> before and after module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> returns its content. However only one module could execute in <code>content</code>. The test indicates module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> wins and command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> from module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> never runs
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;to&nbsp;be&nbsp;proxied<br>
</code><p>To implement what the example had wanted to, we shall use two other commands provided by module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a>,  <a href="http://wiki.nginx.org/HttpEchoModule#echo_before_body" target="_blank">echo_before_body</a> and  <a href="http://wiki.nginx.org/HttpEchoModule#echo_after_body" target="_blank">echo_after_body</a>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_before_body&nbsp;"before...";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;http://127.0.0.1:8080/foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo_after_body&nbsp;"after...";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"contents&nbsp;to&nbsp;be&nbsp;proxied";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Test tells we make it:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/test'<br>
&nbsp;&nbsp;&nbsp;&nbsp;before...<br>
&nbsp;&nbsp;&nbsp;&nbsp;contents&nbsp;to&nbsp;be&nbsp;proxied<br>
&nbsp;&nbsp;&nbsp;&nbsp;after...<br>
</code><p>The reason commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo_before_body" target="_blank">echo_before_body</a> and  <a href="http://wiki.nginx.org/HttpEchoModule#echo_after_body" target="_blank">echo_after_body</a> could coexist with other modules in <code>content</code> phase, is they are not "content handler" but "output filter" of Nginx. Back in <a href="#02-NginxDirectiveExecOrder01">(01)</a> when we examine the "debug log" generated by command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> , we've learnt Nginx calls its "output filter" whenever Nginx outputs data. So that module  <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank">ngx_echo</a> takes the advantage of it to modify content generated by module  <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank">ngx_proxy</a> (by adding surrounding content). We shall point out though, "output filter" is not one of those 11 phases mentioned in <a href="#02-NginxDirectiveExecOrder01">(01)</a> (many phases could trigger "output filter" when they output data). Still it's perfectly all right to document commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo_before_body" target="_blank">echo_before_body</a> and  <a href="http://wiki.nginx.org/HttpEchoModule#echo_after_body" target="_blank">echo_after_body</a> as following:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;phase:&nbsp;output&nbsp;filter<br>
</code><p>It means the command executes in "output filter".</p>
    <h3 id="02-NginxDirectiveExecOrder06">Nginx directive execution order (06)</h3>
<p>We've learnt in <a href="#02-NginxDirectiveExecOrder05">(05)</a> that when a command executes in <code>content</code> phase for a specific <code>location</code>, it usually means its Nginx module registers a "content handler" for the <code>location</code>. However, what happens if no module registers its command as "content handler" for phase <code>content</code> ? Who will be taking the glory of generate content and output responses ? The answer is the static resource module, which maps the request URI to the file system. Static resource module only comes into play when there is none "content handler", otherwise it hands off the duty to "content handler".
</p>
<p>Typically Nginx has three static resource modules for the <code>content</code> phase (unless one or more of those modules are disabled explicitly, or some other conflicting modules are enabled when Nginx is built) The three modules, in the order of their execution order, are  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> module,  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> module and <code>ngx_static</code> module. Let's discuss them one by one.
</p>
<p>Module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> and  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> only apply to those request URI, which ends with <code>/</code>. For the other request URI which does not end with <code>/</code>, both modules ignore them and let the following <code>content</code> phase module handle. Module <code>ngx_static</code> however, has an exact opposite strategy. It ignores the request URI which ends with <code>/</code> and handles the rest.
</p>
<p>Module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> mainly looks for a specific home page file, such as <code>index.html</code> or <code>index.htm</code> in the file system. For example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;/var/www/;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;index.htm&nbsp;index.html;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>When address <code>/</code> is requested, Nginx looks for file <code>index.htm</code> and <code>index.html</code> (in this order) in a path in the file system. The path is specified by command  <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank">root</a>. If file <code>index.htm</code> exists, Nginx jumps internally to location <code>index.htm</code>; if it does not exist and file <code>index.html</code> exists, Nginx jumps internally to location <code>index.html</code>. If file <code>index.html</code> does not exist either, and handling is transferred to the other module which executes it commands in phase <code>content</code>.
</p>
<p>We have learnt in <a href="#01-NginxVariables02">Nginx Variables (02)</a>, commands  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> and  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> can trigger "internal redirects" as well. The jump modifies the request URI, and looks for the corresponding <code>location</code> directive for subsequent handling. In the process, phases <code>rewrite</code>, <code>access</code> and <code>content</code> are reiterated for the <code>location</code>. The "internal redirect" is different from the "external redirect" defined by HTTP response code 302 and 301, client browser won't update its URI addresses. Therefore as soon as internal jump occurs when module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> finds the files specified by command  <a href="http://wiki.nginx.org/HttpIndexModule#index" target="_blank">index</a>, the net effect is like client would have been requesting the file's URI at the very beginning.
</p>
<p>We can check following example to witness the "internal redirect" triggered by module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a>, when it finds the needed file.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;/var/www/;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;index.html;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/index.html&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;32;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"a&nbsp;=&nbsp;$a";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>We need to create an empty file <code>index.html</code> under the path <code>/var/www/</code>, and make sure the file is readable for the Nginx worker process. Then we could send request to <code>/</code>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/'<br>
&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;32<br>
</code><p>What happened ? Why the output is not the content of file <code>index.html</code> (which shall be empty) ? Firstly Nginx uses directive <code>location /</code> to handle original <code>GET /</code> request, then module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> executes in <code>content</code> phase, and it finds file <code>index.html</code> under path <code>/var/www/</code>. At this moment, it triggers an "internal redirect" to location <code>/index.html</code>.
</p>
<p>So far so good. But here comes the surprises ! When Nginx looks for <code>location</code> directive which matches to <code>/index.html</code>, <code>location /index.html</code> has a higher priority than <code>location /</code>. This is because Nginx uses "longest matched substring" semantics to match <code>location</code> directives to request URI's prefix. When <location index.html=""> directive is chosen, phases <code>rewrite</code>, <code>access</code> and <code>content</code> are reiterated, and eventually it outputs <code>a = 32</code>.
</location></p>
<p>What if we remove file <code>/var/www/index.html</code> in the example, and request to <code>/</code> again ? The answer is error <code>403 Forbidden</code>. Why? When module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> cannot find the file specified by command  <a href="http://wiki.nginx.org/HttpIndexModule#index" target="_blank">index</a> (<code>index.html</code> in here), it transfers the handling to the following module which executes in <code>content</code>. But none of those following modules can fulfill the request, Nginx bails out and dumps us error. Meanwhile it logs the error in Nginx error log:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[error]&nbsp;28789#0:&nbsp;*1&nbsp;directory&nbsp;index&nbsp;of&nbsp;"/var/www/"&nbsp;is&nbsp;forbidden<br>
</code><p>The meaning of <code>directory index</code> is to generate "indexes". Usually this implies to generate a web page, which lists every file and sub directories under path <code>/var/www/</code>. If we use module  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> right after  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a>, it can generate such a page just like what we need. Now let's modify the example a little bit:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;/var/www/;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;index.html;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoindex&nbsp;on;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>When <code>/</code> is requested again meanwhile file <code>/var/www/index.html</code> is kept missing. A nice html page is generated:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;html&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;&lt;title&gt;Index&nbsp;of&nbsp;/&lt;/title&gt;&lt;/head&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&nbsp;bgcolor="white"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Index&nbsp;of&nbsp;/&lt;/h1&gt;&lt;hr&gt;&lt;pre&gt;&lt;a&nbsp;href="../"&gt;../&lt;/a&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href="cgi-bin/"&gt;cgi-bin/&lt;/a&gt;&nbsp;&nbsp;08-Mar-2010&nbsp;19:36&nbsp;&nbsp;&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href="error/"&gt;error/&lt;/a&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;08-Mar-2010&nbsp;19:36&nbsp;&nbsp;&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href="htdocs/"&gt;htdocs/&lt;/a&gt;&nbsp;&nbsp;&nbsp;&nbsp;05-Apr-2010&nbsp;03:55&nbsp;&nbsp;&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href="icons/"&gt;icons/&lt;/a&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;08-Mar-2010&nbsp;19:36&nbsp;&nbsp;&nbsp;-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/pre&gt;&lt;hr&gt;&lt;/body&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/html&gt;<br>
</code><p>The page shows there are a few subdirectories under my <code>/var/www/</code>. They are <code>cgi-bin/</code>, <code>error/</code>, <code>htdocs/</code> and <code>icons/</code>. The output might be different if you have tried by yourself.
</p>
<p>Again, if file <code>/var/www/index.hmtl</code> does exist, module  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> will trigger "internal redirect", and module  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> will not have a chance to execute, you may test it yourself too.
</p>
<p>The "goal keeper" module executed in phase <code>content</code> is <code>ngx_static</code>. which is also used intensively. The module serves the static files, including the static resources of a web site, such as static <code>.html</code> files, static <code>.css</code> files, static <code>.js</code> files and static image files etc. Although <code>ngx_index</code> could trigger an "internal redirect" to the specified home page, but the actual output task (takes the file content as response, and marks the corresponding response headers) is carried out by module <code>ngx_static</code>.</p>
    <h3 id="02-NginxDirectiveExecOrder07">Nginx directive execution order (07)</h3>
<p>Let's check an example in which module <code>ngx_static</code> serves disk files, with following configuration snippet:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root&nbsp;/var/www/;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Meanwhile two files are created under <code>/var/www/</code>. One file is named <code>index.html</code> and its content contains one line of text <code>this is my home</code>. Another file is named <code>hello.html</code> and its content contains one line of text <code>hello world</code>. Again be aware of the files' privileges and make sure they are readable by Nginx worker process.
</p>
<p>Now we send requests to the files' corresponding URI:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/index.html'<br>
&nbsp;&nbsp;&nbsp;&nbsp;this&nbsp;is&nbsp;my&nbsp;home<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/hello.html'<br>
&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;world<br>
</code><p>As we can see, the created file contents are sent as outputs.
</p>
<p>We can examine what is happening here: <code>location /</code> does not have any command to execute in phase <code>content</code>, therefore no module has registered a "content handler" in the <code>location</code>. The handling thus falls to the three static resource modules which are the last resorts of phase <code>content</code>. The former two modules  <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank">ngx_index</a> and  <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank">ngx_autoindex</a> notices that the request URI does not end with <code>/</code> so they hand off immediately to module <code>ngx_static</code>, which runs in the end. According to the "document root" specified by command  <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank">root</a>, module <code>ngx_static</code> maps the request URIs <code>/index.html</code> and <code>/hello.html</code> to disk files <code>/var/www/index.html</code> and <code>/var/www/hello.html</code> respectively. As both files can be found, their content are outputted as response, meanwhile response header <code>Content-Type</code>, <code>Content-Length</code> and <code>Last-Modified</code> are accordingly indicated.
</p>
<p>To verify module <code>ngx_static</code> has executed, we could enable the "debug log" introduced in <a href="#02-NginxDirectiveExecOrder01">(01)</a>. Again we send request to <code>/index.html</code> and Nginx error log will contain following debug information:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;3033#0:&nbsp;*1&nbsp;http&nbsp;static&nbsp;fd:&nbsp;8<br>
</code><p>This line is generated by module <code>ngx_static</code>. Its meaning is " outputting static resource whose file handle is <code>8</code>". Of course the numerical file handle changes every time, and the line is only a typical output in my setup. To be reminded, builtin module  <a href="http://wiki.nginx.org/HttpGzipStaticModule" target="_blank">ngx_gzip_static</a> could generate the same debug info as well, by default it is not enabled though, which will be discussed later.
</p>
<p>Command  <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank">root</a> only declares a "document root", it does not enables the <code>ngx_static</code> module. The module is as matter of fact, always enabled already, but it might not have the chance to execute. This is entirely up to the other modules, which execute earlier in <code>content</code> phase. Module <code>ngx_static</code> execute only when all of them have "gave up". To prove this, check following blank <code>location</code> definition:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Because there is no  <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank">root</a> command, Nginx computes a default "document root" when the location is requested. The default shall be the <code>html/</code> subdirectory under "configure prefix". For example suppose our "configure prefix" is <code>/foo/bar/</code>, the default "document root" is <code>/foo/bar/html/</code>.
</p>
<p>So who decides "configure prefix" ? Actually it the Nginx root directory when it is installed (or the value of <code>--prefix</code> option of script <code>./configure</code> when Nginx is built). If Nginx is installed into <code>/usr/local/nginx/</code>, "configure prefix" is <code>/usr/local/nginx/</code> and default "document root" is therefore <code>/usr/local/nginx/html/</code>. Certainly a command line option <code>--prefix</code> can be given when Nginx is started, to change the "configure prefix" (so that we can easily test multiple setups). Suppose Nginx is started as following:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;nginx&nbsp;-p&nbsp;/home/agentzh/test/<br>
</code><p>For this server, its "configure prefix" becomes <code>/home/agentzh/test/</code> and its "document root" becomes <code>/home/agentzh/test/html/</code>. The "configure prefix" not only determines "document root", it actually determines the way many relational path resolutes to absolute path in Nginx configuration. We will encounter many examples which reference "configure prefix".
</p>
<p>In fact there is a simple way of telling current "document root", which is to request a non-existed file, Such as:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;'http://localhost:8080/blah-blah.txt'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;html&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;&lt;title&gt;404&nbsp;Not&nbsp;Found&lt;/title&gt;&lt;/head&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&nbsp;bgcolor="white"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;center&gt;&lt;h1&gt;404&nbsp;Not&nbsp;Found&lt;/h1&gt;&lt;/center&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/html&gt;<br>
</code><p>Naturally, the <code>404</code> error page is returned. Again when we check Nginx error log, we shall have following error message:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[error]&nbsp;9364#0:&nbsp;*1&nbsp;open()&nbsp;"/home/agentzh/test/html/blah-blah.txt"&nbsp;failed&nbsp;(2:&nbsp;No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory)<br>
</code><p>The error message is printed by module <code>ngx_static</code>, since it cannot find a file <code>blah-blah.txt</code> in its corresponding path. And because the error message contains the absolute path, which <code>ngx_static</code> attempts to open with, it's quite obvious that current "document root" is <code>/home/agentzh/test/html/</code>.
</p>
<p>Many newbies might take it for granted that error <code>404</code> is caused when the needed <code>location</code> does not exist. The former example tells us, <code>404</code> error could be returned even if the needed <code>location</code> is configured and matched. This is because error <code>404</code> means the non-existence of a abstract "resource", not the specific <code>location</code>.
</p>
<p>Another frequent mistake is missing the command for phase <code>content</code>, when they actually don't expect the default static modules to come into play,for example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/auth&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;a&nbsp;lot&nbsp;of&nbsp;Lua&nbsp;code&nbsp;omitted&nbsp;here...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Apparently,  only commands for phase <code>access</code> are given for <code>/auth</code>, which is  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a>. And it has no commands for phase <code>content</code>. So when <code>/auth</code> is requested, the Lua code specified in <code>access</code> phase will execute, then the static resource will be served in phase <code>content</code> by module <code>ngx_static</code>. Since it actually looks for the file <code>/auth</code> on the disk normally it dumps a <code>404</code> error unless we are luckily and file <code>/auth</code> is created on the corresponding path. So the thumb of rule, when error <code>404</code> is encountered under no static resource circumstances, we shall first check if the <code>location</code> has properly configured its commands for phase <code>content</code>, the commands can be  <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank">content_by_lua</a>,  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> and  <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank">proxy_pass</a> etc. In fact, Nginx error log <code>error.log</code> could only give very confusing message for the case. As the ones below, which is found for the above example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[error]&nbsp;9364#0:&nbsp;*1&nbsp;open()&nbsp;"/home/agentzh/test/html/auth"&nbsp;failed&nbsp;(2:&nbsp;No&nbsp;such&nbsp;file&nbsp;or&nbsp;directory)<br>
</code>    <h3 id="02-NginxDirectiveExecOrder08">Nginx directive execution order (08)</h3>
<p>So far we have addressed in detail <code>rewrite</code>, <code>access</code> and <code>content</code>, which are also the most frequently encountered phases in Nginx request processing. We have learnt many Nginx modules and their commands that execute in those phases, and it's clear to us that the commands' execution order is directly decided by the phase they are running in. Understanding the phase is our keynote for correct configuration which orchestrates various Nginx modules. Therefore let's cover the rest phases we've not met.
</p>
<p>As mentioned in <a href="#02-NginxDirectiveExecOrder01">(01)</a>, altogether there can be 11 phases when Nginx handles a request. In their execution order the phases are <code>post-read</code>, <code>server-rewrite</code>, <code>find-config</code>, <code>rewrite</code>, <code>post-rewrite</code>, <code>preaccess</code>, <code>access</code>, <code>post-access</code>, <code>try-files</code>, <code>content</code>, and finally <code>log</code>.
</p>
<p>Phase <code>post-read</code> is the very first, commands registered in this phase execute right after Nginx has processed the request headers. Similar to phase <code>rewrite</code> we've learnt earlier, <code>post-read</code> supports hooks by Nginx modules. Built-in module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> is an example, it hooks its handler in <code>post-read</code> phase, and forcefully rewrite the request's original address as the value of a specific request header. The following case illustrates  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> module and its commands  <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank">set_real_ip_from</a>,  <a href="http://wiki.nginx.org/HttpRealIpModule#real_ip_header" target="_blank">real_ip_header</a>.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;127.0.0.1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_ip_header&nbsp;&nbsp;&nbsp;X-My-IP;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$addr&nbsp;$remote_addr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"from:&nbsp;$addr";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>The configuration tells Nginx to forcefully rewrite the original address of every request coming from <code>127.0.0.1</code> to be the value of the request header <code>X-My-IP</code>. Meanwhile it uses the built-in variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> to output the request's original address, so that we know if the rewrite is successful.
</p>
<p>First we send a request to <code>/test</code> from localhost:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;-H&nbsp;'X-My-IP:&nbsp;1.2.3.4'&nbsp;localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;1.2.3.4<br>
</code><p>The test utilizes <code>-H</code> option provided by curl, the option incorporates an extra HTTP header <code>X-My-IP: 1.2.3.4</code> in the request. As we can tell, variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> has become <code>1.2.3.4</code> in <code>rewrite</code> phase, the value comes from the request header <code>X-My-IP</code>. So when does Nginx rewrite the request's original address ? yes it's in the <code>post-read</code> phase. Since phase <code>rewrite</code> is far behind phase <code>post-read</code>, when command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> reads variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a>, its value has already been rewritten in <code>post-read</code> phase.
</p>
<p>If however, the request sent from localhost to <code>/test</code> does not have a <code>X-My-IP</code> header or the header value is an invalid IP address, Nginx will not modify the original address. For example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;127.0.0.1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;-H&nbsp;'X-My-IP:&nbsp;abc'&nbsp;localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;127.0.0.1<br>
</code><p>If a request is sent from another machine to <code>/test</code>, it original address won't be overwritten by Nginx either, even if it has a perfect <code>X-My-IP</code> header. It is because our previous case marks explicitly with command  <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank">set_real_ip_from</a>, that the rewriting only occurs for the requests coming from <code>127.0.0.1</code>. This filtering mechanism protect Nginx from malicious requests sent by untrusted sources. As you might have expected, command  <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank">set_real_ip_from</a> can designate a IP subnet (by using CIDR notation introduced earlier in <a href="#02-NginxDirectiveExecOrder03">(03)</a>). Besides, command  <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank">set_real_ip_from</a> can be used multiple times so that we can setup multiple trusted sources, below is an example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;10.32.10.5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;127.0.0.0/24;<br>
</code><p>You might be asking, what's the benefit module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> brings to us? Why would we rewrite a request's original address ? The answer is: when the request has come through one or more HTTP proxies, the module becomes very handy. When a request is forwarded by a proxy, its original address will become the proxy server's IP address, consequently Nginx and the services running on it will no longer have the actual source. However, we could let proxy server record the original address in a specific header (such as <code>X-My-IP</code>) and recover it in Nginx, so that its subsequent processing (and the services running on Nginx) will take the request as if it comes right from its original address and the proxies in between are transparent. For this exact purpose, module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> needs hook handlers in the first phase, the <code>post-read</code> phase, so the rewriting occurs as early as possible.
</p>
<p>Behind <code>post-phase</code> is the <code>server-rewrite</code> phase. We briefly mentioned in <a href="#02-NginxDirectiveExecOrder02">(02)</a>, when module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> and its commands are configured in <code>server</code> directive, they basically execute in <code>server-rewrite</code> phase. We have an example below:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$b&nbsp;"$a,&nbsp;world";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$b;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;hello;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Attention the <code>set $a hello</code> statement is put in <code>server</code> directive, so it runs in <code>server-rewrite</code> phase, which runs earlier than <code>rewrite</code> phase. Therefore statement <code>set $b "$a, world'"</code> in <code>location</code> directive is executed afterwards and it obtains the correct $a value:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;hello,&nbsp;world<br>
</code><p>Since phase <code>server-rewrite</code> executes later than <code>post-read</code> phase, command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> in <code>server</code> directive always runs later than module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a>, which rewrites the request's original address, example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$addr&nbsp;$remote_addr;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;127.0.0.1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_ip_header&nbsp;&nbsp;&nbsp;X-Real-IP;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"from:&nbsp;$addr";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Send request to <code>/test</code> we have:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;-H&nbsp;'X-Real-IP:&nbsp;1.2.3.4'&nbsp;localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;1.2.3.4<br>
</code><p>Again, command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> is written in front of commands of  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a>, its actual execution is only afterwards. So when command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a> assigns variable <code>$addr</code> in <code>server-rewrite</code> phase, the variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> has been overwritten.</p>
    <h3 id="02-NginxDirectiveExecOrder09">Nginx directive execution order (09)</h3>
<p>Right after <code>server-rewrite</code> is the phase <code>find-config</code>. This phase does not allow Nginx modules to register their handlers, instead it is a phase when Nginx core matches the current request to the <code>location</code> directives. It means a request is not catered by any <code>location</code> directive until it reaches <code>find-config</code>. Apparently, for phases like <code>post-read</code> and <code>server-rewrite</code>, the effective commands are those which get specified only in <code>server</code> directives and their outer directives, because the two phases are executed earlier than <code>find-config</code>. This explains that commands of module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> are executed in phase <code>server-rewrite</code> only if they are written within <code>sever</code> directive. Similarly, the former examples configure the commands of module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> in <code>server</code> directive to make sure the handlers registered in <code>post-read</code> phase could function correctly.
</p>
<p>As soon as Nginx matches a <code>location</code> directive in the <code>find-config</code> phase, it prints a debug log in the error log file. Let's check following example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/hello&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"hello&nbsp;world";<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>If Nginx enables the "debug log", a debug log can be captured in file <code>error.log</code> whenever interface <code>/hello</code> is requested.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;grep&nbsp;'using&nbsp;config'&nbsp;logs/error.log<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;84579#0:&nbsp;*1&nbsp;using&nbsp;configuration&nbsp;"/hello"<br>
</code><p>For the purpose of convenience, the log's time stamp has been omitted.
</p>
<p>After phase <code>find-config</code>, it is our old buddy <code>rewrite</code>. Since Nginx already matches the request to a specific <code>location</code> directive, starting from this phase, commands written within <code>location</code> directives are becoming effective. As illustrated earlier, commands of module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> are executed in <code>rewrite</code> phase when they are written in <code>location</code> directives. Likewise, commands of module  <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank">ngx_set_misc</a> and module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> ( <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank">set_by_lua</a> and  <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank">rewrite_by_lua</a>) are also executed in phase <code>rewrite</code>.
</p>
<p>After <code>rewrite</code>, it is the <code>post-rewrite</code> phase. Just like <code>find-config</code>, this phase does not allow Nginx modules to register their handlers either, instead it carries out the needed "internal redirects" by Nginx core (if this has been requested in <code>rewrite</code> phase). We have addressed the "internal jump" concept in <a href="#02-NginxDirectiveExecOrder02">(02)</a>, and demonstrated how to issue the "internal redirect" with command  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> or command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a>. However, let's focus on command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> for the moment since command  <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank">echo_exec</a> is executed in <code>content</code> phase and becomes irrelevant to <code>post-rewrite</code>, the former draws greater interest because it executes in <code>rewrite</code> phase. Back to our example in <a href="#02-NginxDirectiveExecOrder02">(02)</a>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$a&nbsp;hello;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^&nbsp;/bar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"a&nbsp;=&nbsp;[$a]";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>The command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> found in directive <code>location /foo</code>, rewrites the URI of current request as <code>/bar</code> unconditionally, meanwhile, it issues an "internal redirect" and execution continues from <code>location /bar</code>. What ultimately intrigues us, is the magical bits and pieces of "internal redirect" mechanism, "internal redirect" effectively rewinds our processing of current request back to the <code>find-config</code> phase, so that the <code>location</code> directives can be matched again to the request URI, which usually has been rewritten. Just like our example, whose URI is rewritten as <code>/bar</code> by command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a>, the <code>location /bar</code> directive is matched and execution repeats the <code>rewrite</code> phase thereafter.
</p>
<p>It might not be obvious, that the actual act of rewinding to <code>find-config</code> does not occur in <code>rewrite</code> phase, instead it occurs in the following <code>post-rewrite</code> phase. Command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> in the former example, simply requests Nginx to issue an "internal redirect" in its <code>post-rewrite</code> phase. This design is usually questioned by Nginx beginners and they tend to come up with an idea to execute the "internal jump" directly by command  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a>. The answer however, is fairly simple. The design allows URI be rewritten multiple times in the <code>location</code> directive,which is matched at the very beginning. Such as:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^&nbsp;/bar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^&nbsp;/baz;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;bar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/baz&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;baz;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>The request URI has been rewritten twice in <code>location /foo</code> directive: firstly it becomes <code>/bar</code>, secondly it becomes <code>/baz</code>. As the net effect of both  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank">rewrite</a> statements, "internal redirect" occurs only once in <code>post-rewrite</code> phase. If it would have executed the "internal redirect" at the first URI rewrite, the second would have no chance to be executed since processing would have left current <code>location</code> directive. To prove this we send a request to <code>/foo</code>:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;localhost:8080/foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;baz<br>
</code><p>It can be asserted from the output, the actual jump is from <code>/foo</code> to <code>/baz</code>. We could further prove this by enabling Nginx "debug log" and interrogate the debug log generated in <code>find-config</code> phase for the matched:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;grep&nbsp;'using&nbsp;config'&nbsp;logs/error.log<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;89449#0:&nbsp;*1&nbsp;using&nbsp;configuration&nbsp;"/foo"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;89449#0:&nbsp;*1&nbsp;using&nbsp;configuration&nbsp;"/baz"<br>
</code><p>Clearly, for the specific request, Nginx only matches two <code>location</code> directives: <code>/foo</code> and <code>/baz</code>, and "internal jump" occurs only once.
</p>
<p>Quite obviously, if command <code>ngx_rewrite/rewrite</code> is used to rewrite the request URI in <code>server</code> directive, there won't be any "internal redirects", this is because the URI rewrite is happening in <code>server-rewrite</code> phase, which gets executed earlier than <code>find-config</code> phase that matches in between the <code>location</code> directives. We can check the example below:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;^/foo&nbsp;/bar;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/foo&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;foo;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/bar&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;bar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>In the example, every request whose URI starts with <code>/foo</code> gets its URI rewritten as <code>/bar</code>. The rewriting occurs in <code>server-rewrite</code> phase, and the request has never been matched to any <code>location</code> directive. Only afterwards Nginx executes the matches in <code>find-config</code> phase. So if we send a request to <code>/foo</code>, <code>location /foo</code> never gets matched because when the match occurs in <code>find-config</code> phase, the request URI has been rewritten as <code>/bar</code>. So <code>location /bar</code> is the one and the only one matched directive. Actual output illustrates this:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;localhost:8080/foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;bar<br>
</code><p>Again let's check Nginx "debug log":
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;grep&nbsp;'using&nbsp;config'&nbsp;logs/error.log<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;92693#0:&nbsp;*1&nbsp;using&nbsp;configuration&nbsp;"/bar"<br>
</code><p>As we can tell, Nginx altogether finishes once the <code>location</code> match, and there is no "internal redirect".</p>
    <h3 id="02-NginxDirectiveExecOrder10">Nginx directive execution order (10)</h3>
<p>After <code>post-rewrite</code>, it is the <code>preaccess</code> phase. Just as its name implies, the phase is called <code>preaccess</code> simply because it is executed right before <code>access</code> phase.
</p>
<p>Built-in module  <a href="http://wiki.nginx.org/HttpLimitReqModule" target="_blank">ngx_limit_req</a> and  <a href="http://wiki.nginx.org/HttpLimitZoneModule" target="_blank">ngx_limit_zone</a> are executed in this phase. The former limits the number of requests per hour/minute, and the latter limits the number of simultaneous requests. We will be discussing them more thoroughly afterwards.
</p>
<p>Actually, built-in module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> registers its handler in <code>preaccess</code> as well. You might need to ask then: "why do it again? Did it register its handlers in <code>post-read</code> phase already". Before the answer is uncovered let's study following example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;127.0.0.1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_ip_header&nbsp;X-Real-IP;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"from:&nbsp;$remote_addr";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Comparing to the earlier example, the major difference is that commands of module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> are written in a specific <code>location</code> directive. As we have learnt before, Nginx matches its <code>location</code> directives in <code>find-config</code> phase, which is far behind <code>post-read</code>, hence the request has nothing to do with commands written in any <code>location</code> directive in <code>post-read</code> phase. Back to our example, it is exactly the case where commands are written in a <code>location</code> directive and module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> won't carry out any rewrite of the remote address, because it is not instructed as such in <code>post-read</code> phase.
</p>
<p>What if we do need the rewrite? To help resolve the issue, module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> registers its handlers in <code>preaccess</code> again, so that it is given the chance to execute in a <code>location</code> directive. Now the example runs as we would've expected:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;-H&nbsp;'X-Real-IP:&nbsp;1.2.3.4'&nbsp;localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;1.2.3.4<br>
</code><p>Be really careful though, module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> could easily be misused, as our following example illustrates:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listen&nbsp;8080;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;127.0.0.1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_ip_header&nbsp;X-Real-IP;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;$addr&nbsp;$remote_addr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;"from:&nbsp;$addr";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>In the example, we introduces a variable <code>$addr</code>, to which the value of  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> is saved in <code>rewrite</code> phase. The variable is then used in the output. Slow down right here and you might have noticed the issue, phase <code>rewrite</code> occurs earlier than <code>preaccess</code>, so variable assignment actually happens before module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> has the chance to rewrite the remote address in <code>preaccess</code> phase. The output proves our observation:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;-H&nbsp;'X-Real-IP:&nbsp;1.2.3.4'&nbsp;localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;from:&nbsp;127.0.0.1<br>
</code><p>The output gives the actual remote address (not the rewritten one) Again Nginx "debug log" helps assert it too:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;grep&nbsp;-E&nbsp;'http&nbsp;script&nbsp;(var|set)|realip'&nbsp;logs/error.log<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;var:&nbsp;"127.0.0.1"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$addr<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;realip:&nbsp;"1.2.3.4"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;realip:&nbsp;0100007F&nbsp;FFFFFFFF&nbsp;0100007F<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;var:&nbsp;"127.0.0.1"<br>
</code><p>Among the logs, the first line writes:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;var:&nbsp;"127.0.0.1"<br>
</code><p>The log is generated when variable  <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank">$remote_addr</a> is fetched by command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>, string <code>"127.0.0.1"</code> is the fetched value.
</p>
<p>The second line writes:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;set&nbsp;$addr<br>
</code><p>It indicates Nginx assigns value to variable <code>$addr</code>.
</p>
<p>For the following two lines:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;realip:&nbsp;"1.2.3.4"<br>
&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;realip:&nbsp;0100007F&nbsp;FFFFFFFF&nbsp;0100007F<br>
</code><p>They are generated when module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> rewrites the remote address in <code>preaccess</code> phase. As we can tell, the new address becomes <code>1.2.3.4</code> as expected but it happens only after the variable assignment and that's already too late.
</p>
<p>Now the last line:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[debug]&nbsp;32488#0:&nbsp;*1&nbsp;http&nbsp;script&nbsp;var:&nbsp;"127.0.0.1"<br>
</code><p>It is generated when command  <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank">echo</a> outputs variable <code>$addr</code>, clearly the value is the original remote address, not the rewritten one.
</p>
<p>Some people might come up with a solution immediately:" what if module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> registers its handlers in <code>rewrite</code> phase instead, not in <code>preacccess</code> phase ?" The solution however is, not necessarily correct. This is because module  <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank">ngx_rewrite</a> registers its handlers in <code>rewrite</code> phase too, and we have learnt in <a href="#02-NginxDirectiveExecOrder02">(02)</a> that the execution order, under the circumstances, can not be guaranteed, so there is a good chance that module  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> still executes its commands after command  <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank">set</a>.
</p>
<p>Always we have the backup option: instead of <code>preaccess</code>, try use  <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank">ngx_realip</a> module in <code>server</code> directive, it bypasses the bothersome situations encountered above.
</p>
<p>After phase <code>preaccess</code>, it is another old friend, the <code>access</code> phase. As we've learnt, built-in module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a>, 3rd party module <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank">ngx_auth_request</a> and 3rd party module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> ( <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a>) have their commands executed in this phase.
</p>
<p>After phase <code>access</code>, it is the <code>post-access</code> phase. Again as the name implies, we can easily spot that the phase is executed right after <code>access</code> phase. Similar to <code>post-rewrite</code>, the phase does not allow Nginx module to register their handlers, instead it runs a few tasks by Nginx core, among them, primarily is the  <a href="http://wiki.nginx.org/HttpCoreModule#satisfy" target="_blank">satisfy</a> functionality, provided by module <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank">ngx_http_core</a>.
</p>
<p>When multiple Nginx module execute their commands in <code>access</code> phase, command  <a href="http://wiki.nginx.org/HttpCoreModule#satisfy" target="_blank">satisfy</a> controls their relationships in between. For example, both module A and module B register their access control handlers in <code>access</code> phase, we may have two working modes, one is to let access when both A and B pass their control, the other is to let access when either A or B pass their control. The first one is called <code>all</code> mode ("AND" relation), the second one is called <code>any</code> mode ("OR" relation) By default, Nginx uses <code>all</code> mode, below is an example:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;satisfy&nbsp;all;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'ngx.exit(ngx.OK)';<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;something&nbsp;important;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Under <code>/test</code> directive, both  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> and  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> are used, so we have two modules monitoring access in <code>access</code> phase. Specifically, statement <code>deny all</code> tells module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> to rejects all access, whereas statement <code>access_by_lua 'ngx.exit(ngx.OK)'</code> allows all access. When <code>all</code> mode is used with command  <a href="http://wiki.nginx.org/HttpCoreModule#satisfy" target="_blank">satisfy</a>, it means to let access only if every module allows access. Since module  <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank">ngx_access</a> always rejects in our case, the request is rejected:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;html&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;&lt;title&gt;403&nbsp;Forbidden&lt;/title&gt;&lt;/head&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&nbsp;bgcolor="white"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;center&gt;&lt;h1&gt;403&nbsp;Forbidden&lt;/h1&gt;&lt;/center&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/html&gt;<br>
</code><p>Careful readers might find following error log in the Nginx error log file:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;[error]&nbsp;6549#0:&nbsp;*1&nbsp;access&nbsp;forbidden&nbsp;by&nbsp;rule<br>
</code><p>If however, we change the <code>satisfy all</code> statement to <code>satisfy any</code>.
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;satisfy&nbsp;any;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'ngx.exit(ngx.OK)';<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;something&nbsp;important;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>The outcome is completely different:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;curl&nbsp;localhost:8080/test<br>
&nbsp;&nbsp;&nbsp;&nbsp;something&nbsp;important<br>
</code><p>The request is allowed to access. Because overall access is allowed whenever one module passes the control in <code>any</code> mode. In our example, module  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> and its command  <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank">access_by_lua</a> always allow the access.
</p>
<p>Certainly, if every module rejects the access in the <code>satisfy any</code> circumstances, the request will be rejected:
</p>
<code>&nbsp;&nbsp;&nbsp;&nbsp;location&nbsp;/test&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;satisfy&nbsp;any;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access_by_lua&nbsp;'ngx.exit(ngx.HTTP_FORBIDDEN)';<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;something&nbsp;important;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</code><p>Now request to <code>/test</code> will encounter <code>403 Forbidden</code> error page. In the process, the "OR" relation of access control of each <code>access</code> module, is implemented in <code>post-access</code>.
</p>
<p>Please note that this example requires at least  <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank">ngx_lua</a> 0.5.0rc19 or later; earlier versions cannot work with the <code>satisfy any</code> statement.</p>
</div>
</div>
</body></html>